{"ast":null,"code":"import stream from 'stream';\nimport string_decoder from 'string_decoder';\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar sax = createCommonjsModule(function (module, exports) {\n  (function (sax) {\n    // wrapper for non-node envs\n    sax.parser = function (strict, opt) {\n      return new SAXParser(strict, opt);\n    };\n\n    sax.SAXParser = SAXParser;\n    sax.SAXStream = SAXStream;\n    sax.createStream = createStream; // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n    // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n    // since that's the earliest that a buffer overrun could occur.  This way, checks are\n    // as rare as required, but as often as necessary to ensure never crossing this bound.\n    // Furthermore, buffers are only tested at most once per write(), so passing a very\n    // large string into write() might have undesirable effects, but this is manageable by\n    // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n    // edge case, result in creating at most one complete copy of the string passed in.\n    // Set to Infinity to have unlimited buffers.\n\n    sax.MAX_BUFFER_LENGTH = 64 * 1024;\n    var buffers = ['comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype', 'procInstName', 'procInstBody', 'entity', 'attribName', 'attribValue', 'cdata', 'script'];\n    sax.EVENTS = ['text', 'processinginstruction', 'sgmldeclaration', 'doctype', 'comment', 'opentagstart', 'attribute', 'opentag', 'closetag', 'opencdata', 'cdata', 'closecdata', 'error', 'end', 'ready', 'script', 'opennamespace', 'closenamespace'];\n\n    function SAXParser(strict, opt) {\n      if (!(this instanceof SAXParser)) {\n        return new SAXParser(strict, opt);\n      }\n\n      var parser = this;\n      clearBuffers(parser);\n      parser.q = parser.c = '';\n      parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n      parser.opt = opt || {};\n      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n      parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';\n      parser.tags = [];\n      parser.closed = parser.closedRoot = parser.sawRoot = false;\n      parser.tag = parser.error = null;\n      parser.strict = !!strict;\n      parser.noscript = !!(strict || parser.opt.noscript);\n      parser.state = S.BEGIN;\n      parser.strictEntities = parser.opt.strictEntities;\n      parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);\n      parser.attribList = []; // namespaces form a prototype chain.\n      // it always points at the current tag,\n      // which protos to its parent tag.\n\n      if (parser.opt.xmlns) {\n        parser.ns = Object.create(rootNS);\n      } // mostly just for error reporting\n\n\n      parser.trackPosition = parser.opt.position !== false;\n\n      if (parser.trackPosition) {\n        parser.position = parser.line = parser.column = 0;\n      }\n\n      emit(parser, 'onready');\n    }\n\n    if (!Object.create) {\n      Object.create = function (o) {\n        function F() {}\n\n        F.prototype = o;\n        var newf = new F();\n        return newf;\n      };\n    }\n\n    if (!Object.keys) {\n      Object.keys = function (o) {\n        var a = [];\n\n        for (var i in o) if (o.hasOwnProperty(i)) a.push(i);\n\n        return a;\n      };\n    }\n\n    function checkBufferLength(parser) {\n      var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);\n      var maxActual = 0;\n\n      for (var i = 0, l = buffers.length; i < l; i++) {\n        var len = parser[buffers[i]].length;\n\n        if (len > maxAllowed) {\n          // Text/cdata nodes can get big, and since they're buffered,\n          // we can get here under normal conditions.\n          // Avoid issues by emitting the text node now,\n          // so at least it won't get any bigger.\n          switch (buffers[i]) {\n            case 'textNode':\n              closeText(parser);\n              break;\n\n            case 'cdata':\n              emitNode(parser, 'oncdata', parser.cdata);\n              parser.cdata = '';\n              break;\n\n            case 'script':\n              emitNode(parser, 'onscript', parser.script);\n              parser.script = '';\n              break;\n\n            default:\n              error(parser, 'Max buffer length exceeded: ' + buffers[i]);\n          }\n        }\n\n        maxActual = Math.max(maxActual, len);\n      } // schedule the next check for the earliest possible buffer overrun.\n\n\n      var m = sax.MAX_BUFFER_LENGTH - maxActual;\n      parser.bufferCheckPosition = m + parser.position;\n    }\n\n    function clearBuffers(parser) {\n      for (var i = 0, l = buffers.length; i < l; i++) {\n        parser[buffers[i]] = '';\n      }\n    }\n\n    function flushBuffers(parser) {\n      closeText(parser);\n\n      if (parser.cdata !== '') {\n        emitNode(parser, 'oncdata', parser.cdata);\n        parser.cdata = '';\n      }\n\n      if (parser.script !== '') {\n        emitNode(parser, 'onscript', parser.script);\n        parser.script = '';\n      }\n    }\n\n    SAXParser.prototype = {\n      end: function () {\n        end(this);\n      },\n      write: write,\n      resume: function () {\n        this.error = null;\n        return this;\n      },\n      close: function () {\n        return this.write(null);\n      },\n      flush: function () {\n        flushBuffers(this);\n      }\n    };\n    var Stream;\n\n    try {\n      Stream = stream.Stream;\n    } catch (ex) {\n      Stream = function () {};\n    }\n\n    var streamWraps = sax.EVENTS.filter(function (ev) {\n      return ev !== 'error' && ev !== 'end';\n    });\n\n    function createStream(strict, opt) {\n      return new SAXStream(strict, opt);\n    }\n\n    function SAXStream(strict, opt) {\n      if (!(this instanceof SAXStream)) {\n        return new SAXStream(strict, opt);\n      }\n\n      Stream.apply(this);\n      this._parser = new SAXParser(strict, opt);\n      this.writable = true;\n      this.readable = true;\n      var me = this;\n\n      this._parser.onend = function () {\n        me.emit('end');\n      };\n\n      this._parser.onerror = function (er) {\n        me.emit('error', er); // if didn't throw, then means error was handled.\n        // go ahead and clear error, so we can write again.\n\n        me._parser.error = null;\n      };\n\n      this._decoder = null;\n      streamWraps.forEach(function (ev) {\n        Object.defineProperty(me, 'on' + ev, {\n          get: function () {\n            return me._parser['on' + ev];\n          },\n          set: function (h) {\n            if (!h) {\n              me.removeAllListeners(ev);\n              me._parser['on' + ev] = h;\n              return h;\n            }\n\n            me.on(ev, h);\n          },\n          enumerable: true,\n          configurable: false\n        });\n      });\n    }\n\n    SAXStream.prototype = Object.create(Stream.prototype, {\n      constructor: {\n        value: SAXStream\n      }\n    });\n\n    SAXStream.prototype.write = function (data) {\n      if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {\n        if (!this._decoder) {\n          var SD = string_decoder.StringDecoder;\n          this._decoder = new SD('utf8');\n        }\n\n        data = this._decoder.write(data);\n      }\n\n      this._parser.write(data.toString());\n\n      this.emit('data', data);\n      return true;\n    };\n\n    SAXStream.prototype.end = function (chunk) {\n      if (chunk && chunk.length) {\n        this.write(chunk);\n      }\n\n      this._parser.end();\n\n      return true;\n    };\n\n    SAXStream.prototype.on = function (ev, handler) {\n      var me = this;\n\n      if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {\n        me._parser['on' + ev] = function () {\n          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);\n          args.splice(0, 0, ev);\n          me.emit.apply(me, args);\n        };\n      }\n\n      return Stream.prototype.on.call(me, ev, handler);\n    }; // this really needs to be replaced with character classes.\n    // XML allows all manner of ridiculous numbers and digits.\n\n\n    var CDATA = '[CDATA[';\n    var DOCTYPE = 'DOCTYPE';\n    var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';\n    var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';\n    var rootNS = {\n      xml: XML_NAMESPACE,\n      xmlns: XMLNS_NAMESPACE\n    }; // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n    // This implementation works on strings, a single character at a time\n    // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n    // without a significant breaking change to either this  parser, or the\n    // JavaScript language.  Implementation of an emoji-capable xml parser\n    // is left as an exercise for the reader.\n\n    var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n    var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n    var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n    var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n\n    function isWhitespace(c) {\n      return c === ' ' || c === '\\n' || c === '\\r' || c === '\\t';\n    }\n\n    function isQuote(c) {\n      return c === '\"' || c === '\\'';\n    }\n\n    function isAttribEnd(c) {\n      return c === '>' || isWhitespace(c);\n    }\n\n    function isMatch(regex, c) {\n      return regex.test(c);\n    }\n\n    function notMatch(regex, c) {\n      return !isMatch(regex, c);\n    }\n\n    var S = 0;\n    sax.STATE = {\n      BEGIN: S++,\n      // leading byte order mark or whitespace\n      BEGIN_WHITESPACE: S++,\n      // leading whitespace\n      TEXT: S++,\n      // general stuff\n      TEXT_ENTITY: S++,\n      // &amp and such.\n      OPEN_WAKA: S++,\n      // <\n      SGML_DECL: S++,\n      // <!BLARG\n      SGML_DECL_QUOTED: S++,\n      // <!BLARG foo \"bar\n      DOCTYPE: S++,\n      // <!DOCTYPE\n      DOCTYPE_QUOTED: S++,\n      // <!DOCTYPE \"//blah\n      DOCTYPE_DTD: S++,\n      // <!DOCTYPE \"//blah\" [ ...\n      DOCTYPE_DTD_QUOTED: S++,\n      // <!DOCTYPE \"//blah\" [ \"foo\n      COMMENT_STARTING: S++,\n      // <!-\n      COMMENT: S++,\n      // <!--\n      COMMENT_ENDING: S++,\n      // <!-- blah -\n      COMMENT_ENDED: S++,\n      // <!-- blah --\n      CDATA: S++,\n      // <![CDATA[ something\n      CDATA_ENDING: S++,\n      // ]\n      CDATA_ENDING_2: S++,\n      // ]]\n      PROC_INST: S++,\n      // <?hi\n      PROC_INST_BODY: S++,\n      // <?hi there\n      PROC_INST_ENDING: S++,\n      // <?hi \"there\" ?\n      OPEN_TAG: S++,\n      // <strong\n      OPEN_TAG_SLASH: S++,\n      // <strong /\n      ATTRIB: S++,\n      // <a\n      ATTRIB_NAME: S++,\n      // <a foo\n      ATTRIB_NAME_SAW_WHITE: S++,\n      // <a foo _\n      ATTRIB_VALUE: S++,\n      // <a foo=\n      ATTRIB_VALUE_QUOTED: S++,\n      // <a foo=\"bar\n      ATTRIB_VALUE_CLOSED: S++,\n      // <a foo=\"bar\"\n      ATTRIB_VALUE_UNQUOTED: S++,\n      // <a foo=bar\n      ATTRIB_VALUE_ENTITY_Q: S++,\n      // <foo bar=\"&quot;\"\n      ATTRIB_VALUE_ENTITY_U: S++,\n      // <foo bar=&quot\n      CLOSE_TAG: S++,\n      // </a\n      CLOSE_TAG_SAW_WHITE: S++,\n      // </a   >\n      SCRIPT: S++,\n      // <script> ...\n      SCRIPT_ENDING: S++ // <script> ... <\n\n    };\n    sax.XML_ENTITIES = {\n      'amp': '&',\n      'gt': '>',\n      'lt': '<',\n      'quot': '\"',\n      'apos': \"'\"\n    };\n    sax.ENTITIES = {\n      'amp': '&',\n      'gt': '>',\n      'lt': '<',\n      'quot': '\"',\n      'apos': \"'\",\n      'AElig': 198,\n      'Aacute': 193,\n      'Acirc': 194,\n      'Agrave': 192,\n      'Aring': 197,\n      'Atilde': 195,\n      'Auml': 196,\n      'Ccedil': 199,\n      'ETH': 208,\n      'Eacute': 201,\n      'Ecirc': 202,\n      'Egrave': 200,\n      'Euml': 203,\n      'Iacute': 205,\n      'Icirc': 206,\n      'Igrave': 204,\n      'Iuml': 207,\n      'Ntilde': 209,\n      'Oacute': 211,\n      'Ocirc': 212,\n      'Ograve': 210,\n      'Oslash': 216,\n      'Otilde': 213,\n      'Ouml': 214,\n      'THORN': 222,\n      'Uacute': 218,\n      'Ucirc': 219,\n      'Ugrave': 217,\n      'Uuml': 220,\n      'Yacute': 221,\n      'aacute': 225,\n      'acirc': 226,\n      'aelig': 230,\n      'agrave': 224,\n      'aring': 229,\n      'atilde': 227,\n      'auml': 228,\n      'ccedil': 231,\n      'eacute': 233,\n      'ecirc': 234,\n      'egrave': 232,\n      'eth': 240,\n      'euml': 235,\n      'iacute': 237,\n      'icirc': 238,\n      'igrave': 236,\n      'iuml': 239,\n      'ntilde': 241,\n      'oacute': 243,\n      'ocirc': 244,\n      'ograve': 242,\n      'oslash': 248,\n      'otilde': 245,\n      'ouml': 246,\n      'szlig': 223,\n      'thorn': 254,\n      'uacute': 250,\n      'ucirc': 251,\n      'ugrave': 249,\n      'uuml': 252,\n      'yacute': 253,\n      'yuml': 255,\n      'copy': 169,\n      'reg': 174,\n      'nbsp': 160,\n      'iexcl': 161,\n      'cent': 162,\n      'pound': 163,\n      'curren': 164,\n      'yen': 165,\n      'brvbar': 166,\n      'sect': 167,\n      'uml': 168,\n      'ordf': 170,\n      'laquo': 171,\n      'not': 172,\n      'shy': 173,\n      'macr': 175,\n      'deg': 176,\n      'plusmn': 177,\n      'sup1': 185,\n      'sup2': 178,\n      'sup3': 179,\n      'acute': 180,\n      'micro': 181,\n      'para': 182,\n      'middot': 183,\n      'cedil': 184,\n      'ordm': 186,\n      'raquo': 187,\n      'frac14': 188,\n      'frac12': 189,\n      'frac34': 190,\n      'iquest': 191,\n      'times': 215,\n      'divide': 247,\n      'OElig': 338,\n      'oelig': 339,\n      'Scaron': 352,\n      'scaron': 353,\n      'Yuml': 376,\n      'fnof': 402,\n      'circ': 710,\n      'tilde': 732,\n      'Alpha': 913,\n      'Beta': 914,\n      'Gamma': 915,\n      'Delta': 916,\n      'Epsilon': 917,\n      'Zeta': 918,\n      'Eta': 919,\n      'Theta': 920,\n      'Iota': 921,\n      'Kappa': 922,\n      'Lambda': 923,\n      'Mu': 924,\n      'Nu': 925,\n      'Xi': 926,\n      'Omicron': 927,\n      'Pi': 928,\n      'Rho': 929,\n      'Sigma': 931,\n      'Tau': 932,\n      'Upsilon': 933,\n      'Phi': 934,\n      'Chi': 935,\n      'Psi': 936,\n      'Omega': 937,\n      'alpha': 945,\n      'beta': 946,\n      'gamma': 947,\n      'delta': 948,\n      'epsilon': 949,\n      'zeta': 950,\n      'eta': 951,\n      'theta': 952,\n      'iota': 953,\n      'kappa': 954,\n      'lambda': 955,\n      'mu': 956,\n      'nu': 957,\n      'xi': 958,\n      'omicron': 959,\n      'pi': 960,\n      'rho': 961,\n      'sigmaf': 962,\n      'sigma': 963,\n      'tau': 964,\n      'upsilon': 965,\n      'phi': 966,\n      'chi': 967,\n      'psi': 968,\n      'omega': 969,\n      'thetasym': 977,\n      'upsih': 978,\n      'piv': 982,\n      'ensp': 8194,\n      'emsp': 8195,\n      'thinsp': 8201,\n      'zwnj': 8204,\n      'zwj': 8205,\n      'lrm': 8206,\n      'rlm': 8207,\n      'ndash': 8211,\n      'mdash': 8212,\n      'lsquo': 8216,\n      'rsquo': 8217,\n      'sbquo': 8218,\n      'ldquo': 8220,\n      'rdquo': 8221,\n      'bdquo': 8222,\n      'dagger': 8224,\n      'Dagger': 8225,\n      'bull': 8226,\n      'hellip': 8230,\n      'permil': 8240,\n      'prime': 8242,\n      'Prime': 8243,\n      'lsaquo': 8249,\n      'rsaquo': 8250,\n      'oline': 8254,\n      'frasl': 8260,\n      'euro': 8364,\n      'image': 8465,\n      'weierp': 8472,\n      'real': 8476,\n      'trade': 8482,\n      'alefsym': 8501,\n      'larr': 8592,\n      'uarr': 8593,\n      'rarr': 8594,\n      'darr': 8595,\n      'harr': 8596,\n      'crarr': 8629,\n      'lArr': 8656,\n      'uArr': 8657,\n      'rArr': 8658,\n      'dArr': 8659,\n      'hArr': 8660,\n      'forall': 8704,\n      'part': 8706,\n      'exist': 8707,\n      'empty': 8709,\n      'nabla': 8711,\n      'isin': 8712,\n      'notin': 8713,\n      'ni': 8715,\n      'prod': 8719,\n      'sum': 8721,\n      'minus': 8722,\n      'lowast': 8727,\n      'radic': 8730,\n      'prop': 8733,\n      'infin': 8734,\n      'ang': 8736,\n      'and': 8743,\n      'or': 8744,\n      'cap': 8745,\n      'cup': 8746,\n      'int': 8747,\n      'there4': 8756,\n      'sim': 8764,\n      'cong': 8773,\n      'asymp': 8776,\n      'ne': 8800,\n      'equiv': 8801,\n      'le': 8804,\n      'ge': 8805,\n      'sub': 8834,\n      'sup': 8835,\n      'nsub': 8836,\n      'sube': 8838,\n      'supe': 8839,\n      'oplus': 8853,\n      'otimes': 8855,\n      'perp': 8869,\n      'sdot': 8901,\n      'lceil': 8968,\n      'rceil': 8969,\n      'lfloor': 8970,\n      'rfloor': 8971,\n      'lang': 9001,\n      'rang': 9002,\n      'loz': 9674,\n      'spades': 9824,\n      'clubs': 9827,\n      'hearts': 9829,\n      'diams': 9830\n    };\n    Object.keys(sax.ENTITIES).forEach(function (key) {\n      var e = sax.ENTITIES[key];\n      var s = typeof e === 'number' ? String.fromCharCode(e) : e;\n      sax.ENTITIES[key] = s;\n    });\n\n    for (var s in sax.STATE) {\n      sax.STATE[sax.STATE[s]] = s;\n    } // shorthand\n\n\n    S = sax.STATE;\n\n    function emit(parser, event, data) {\n      parser[event] && parser[event](data);\n    }\n\n    function emitNode(parser, nodeType, data) {\n      if (parser.textNode) closeText(parser);\n      emit(parser, nodeType, data);\n    }\n\n    function closeText(parser) {\n      parser.textNode = textopts(parser.opt, parser.textNode);\n      if (parser.textNode) emit(parser, 'ontext', parser.textNode);\n      parser.textNode = '';\n    }\n\n    function textopts(opt, text) {\n      if (opt.trim) text = text.trim();\n      if (opt.normalize) text = text.replace(/\\s+/g, ' ');\n      return text;\n    }\n\n    function error(parser, er) {\n      closeText(parser);\n\n      if (parser.trackPosition) {\n        er += '\\nLine: ' + parser.line + '\\nColumn: ' + parser.column + '\\nChar: ' + parser.c;\n      }\n\n      er = new Error(er);\n      parser.error = er;\n      emit(parser, 'onerror', er);\n      return parser;\n    }\n\n    function end(parser) {\n      if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');\n\n      if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {\n        error(parser, 'Unexpected end');\n      }\n\n      closeText(parser);\n      parser.c = '';\n      parser.closed = true;\n      emit(parser, 'onend');\n      SAXParser.call(parser, parser.strict, parser.opt);\n      return parser;\n    }\n\n    function strictFail(parser, message) {\n      if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {\n        throw new Error('bad call to strictFail');\n      }\n\n      if (parser.strict) {\n        error(parser, message);\n      }\n    }\n\n    function newTag(parser) {\n      if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n      var tag = parser.tag = {\n        name: parser.tagName,\n        attributes: {}\n      }; // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n\n      if (parser.opt.xmlns) {\n        tag.ns = parent.ns;\n      }\n\n      parser.attribList.length = 0;\n      emitNode(parser, 'onopentagstart', tag);\n    }\n\n    function qname(name, attribute) {\n      var i = name.indexOf(':');\n      var qualName = i < 0 ? ['', name] : name.split(':');\n      var prefix = qualName[0];\n      var local = qualName[1]; // <x \"xmlns\"=\"http://foo\">\n\n      if (attribute && name === 'xmlns') {\n        prefix = 'xmlns';\n        local = '';\n      }\n\n      return {\n        prefix: prefix,\n        local: local\n      };\n    }\n\n    function attrib(parser) {\n      if (!parser.strict) {\n        parser.attribName = parser.attribName[parser.looseCase]();\n      }\n\n      if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n        parser.attribName = parser.attribValue = '';\n        return;\n      }\n\n      if (parser.opt.xmlns) {\n        var qn = qname(parser.attribName, true);\n        var prefix = qn.prefix;\n        var local = qn.local;\n\n        if (prefix === 'xmlns') {\n          // namespace binding attribute. push the binding into scope\n          if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n            strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\\n' + 'Actual: ' + parser.attribValue);\n          } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {\n            strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\\n' + 'Actual: ' + parser.attribValue);\n          } else {\n            var tag = parser.tag;\n            var parent = parser.tags[parser.tags.length - 1] || parser;\n\n            if (tag.ns === parent.ns) {\n              tag.ns = Object.create(parent.ns);\n            }\n\n            tag.ns[local] = parser.attribValue;\n          }\n        } // defer onattribute events until all attributes have been seen\n        // so any new bindings can take effect. preserve attribute order\n        // so deferred events can be emitted in document order\n\n\n        parser.attribList.push([parser.attribName, parser.attribValue]);\n      } else {\n        // in non-xmlns mode, we can emit the event right away\n        parser.tag.attributes[parser.attribName] = parser.attribValue;\n        emitNode(parser, 'onattribute', {\n          name: parser.attribName,\n          value: parser.attribValue\n        });\n      }\n\n      parser.attribName = parser.attribValue = '';\n    }\n\n    function openTag(parser, selfClosing) {\n      if (parser.opt.xmlns) {\n        // emit namespace binding events\n        var tag = parser.tag; // add namespace info to tag\n\n        var qn = qname(parser.tagName);\n        tag.prefix = qn.prefix;\n        tag.local = qn.local;\n        tag.uri = tag.ns[qn.prefix] || '';\n\n        if (tag.prefix && !tag.uri) {\n          strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(parser.tagName));\n          tag.uri = qn.prefix;\n        }\n\n        var parent = parser.tags[parser.tags.length - 1] || parser;\n\n        if (tag.ns && parent.ns !== tag.ns) {\n          Object.keys(tag.ns).forEach(function (p) {\n            emitNode(parser, 'onopennamespace', {\n              prefix: p,\n              uri: tag.ns[p]\n            });\n          });\n        } // handle deferred onattribute events\n        // Note: do not apply default ns to attributes:\n        //   http://www.w3.org/TR/REC-xml-names/#defaulting\n\n\n        for (var i = 0, l = parser.attribList.length; i < l; i++) {\n          var nv = parser.attribList[i];\n          var name = nv[0];\n          var value = nv[1];\n          var qualName = qname(name, true);\n          var prefix = qualName.prefix;\n          var local = qualName.local;\n          var uri = prefix === '' ? '' : tag.ns[prefix] || '';\n          var a = {\n            name: name,\n            value: value,\n            prefix: prefix,\n            local: local,\n            uri: uri\n          }; // if there's any attributes with an undefined namespace,\n          // then fail on them now.\n\n          if (prefix && prefix !== 'xmlns' && !uri) {\n            strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(prefix));\n            a.uri = prefix;\n          }\n\n          parser.tag.attributes[name] = a;\n          emitNode(parser, 'onattribute', a);\n        }\n\n        parser.attribList.length = 0;\n      }\n\n      parser.tag.isSelfClosing = !!selfClosing; // process the tag\n\n      parser.sawRoot = true;\n      parser.tags.push(parser.tag);\n      emitNode(parser, 'onopentag', parser.tag);\n\n      if (!selfClosing) {\n        // special case for <script> in non-strict mode.\n        if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n          parser.state = S.SCRIPT;\n        } else {\n          parser.state = S.TEXT;\n        }\n\n        parser.tag = null;\n        parser.tagName = '';\n      }\n\n      parser.attribName = parser.attribValue = '';\n      parser.attribList.length = 0;\n    }\n\n    function closeTag(parser) {\n      if (!parser.tagName) {\n        strictFail(parser, 'Weird empty close tag.');\n        parser.textNode += '</>';\n        parser.state = S.TEXT;\n        return;\n      }\n\n      if (parser.script) {\n        if (parser.tagName !== 'script') {\n          parser.script += '</' + parser.tagName + '>';\n          parser.tagName = '';\n          parser.state = S.SCRIPT;\n          return;\n        }\n\n        emitNode(parser, 'onscript', parser.script);\n        parser.script = '';\n      } // first make sure that the closing tag actually exists.\n      // <a><b></c></b></a> will close everything, otherwise.\n\n\n      var t = parser.tags.length;\n      var tagName = parser.tagName;\n\n      if (!parser.strict) {\n        tagName = tagName[parser.looseCase]();\n      }\n\n      var closeTo = tagName;\n\n      while (t--) {\n        var close = parser.tags[t];\n\n        if (close.name !== closeTo) {\n          // fail the first time in strict mode\n          strictFail(parser, 'Unexpected close tag');\n        } else {\n          break;\n        }\n      } // didn't find it.  we already failed for strict, so just abort.\n\n\n      if (t < 0) {\n        strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);\n        parser.textNode += '</' + parser.tagName + '>';\n        parser.state = S.TEXT;\n        return;\n      }\n\n      parser.tagName = tagName;\n      var s = parser.tags.length;\n\n      while (s-- > t) {\n        var tag = parser.tag = parser.tags.pop();\n        parser.tagName = parser.tag.name;\n        emitNode(parser, 'onclosetag', parser.tagName);\n        var x = {};\n\n        for (var i in tag.ns) {\n          x[i] = tag.ns[i];\n        }\n\n        var parent = parser.tags[parser.tags.length - 1] || parser;\n\n        if (parser.opt.xmlns && tag.ns !== parent.ns) {\n          // remove namespace bindings introduced by tag\n          Object.keys(tag.ns).forEach(function (p) {\n            var n = tag.ns[p];\n            emitNode(parser, 'onclosenamespace', {\n              prefix: p,\n              uri: n\n            });\n          });\n        }\n      }\n\n      if (t === 0) parser.closedRoot = true;\n      parser.tagName = parser.attribValue = parser.attribName = '';\n      parser.attribList.length = 0;\n      parser.state = S.TEXT;\n    }\n\n    function parseEntity(parser) {\n      var entity = parser.entity;\n      var entityLC = entity.toLowerCase();\n      var num;\n      var numStr = '';\n\n      if (parser.ENTITIES[entity]) {\n        return parser.ENTITIES[entity];\n      }\n\n      if (parser.ENTITIES[entityLC]) {\n        return parser.ENTITIES[entityLC];\n      }\n\n      entity = entityLC;\n\n      if (entity.charAt(0) === '#') {\n        if (entity.charAt(1) === 'x') {\n          entity = entity.slice(2);\n          num = parseInt(entity, 16);\n          numStr = num.toString(16);\n        } else {\n          entity = entity.slice(1);\n          num = parseInt(entity, 10);\n          numStr = num.toString(10);\n        }\n      }\n\n      entity = entity.replace(/^0+/, '');\n\n      if (isNaN(num) || numStr.toLowerCase() !== entity) {\n        strictFail(parser, 'Invalid character entity');\n        return '&' + parser.entity + ';';\n      }\n\n      return String.fromCodePoint(num);\n    }\n\n    function beginWhiteSpace(parser, c) {\n      if (c === '<') {\n        parser.state = S.OPEN_WAKA;\n        parser.startTagPosition = parser.position;\n      } else if (!isWhitespace(c)) {\n        // have to process this as a text node.\n        // weird, but happens.\n        strictFail(parser, 'Non-whitespace before first tag.');\n        parser.textNode = c;\n        parser.state = S.TEXT;\n      }\n    }\n\n    function charAt(chunk, i) {\n      var result = '';\n\n      if (i < chunk.length) {\n        result = chunk.charAt(i);\n      }\n\n      return result;\n    }\n\n    function write(chunk) {\n      var parser = this;\n\n      if (this.error) {\n        throw this.error;\n      }\n\n      if (parser.closed) {\n        return error(parser, 'Cannot write after close. Assign an onready handler.');\n      }\n\n      if (chunk === null) {\n        return end(parser);\n      }\n\n      if (typeof chunk === 'object') {\n        chunk = chunk.toString();\n      }\n\n      var i = 0;\n      var c = '';\n\n      while (true) {\n        c = charAt(chunk, i++);\n        parser.c = c;\n\n        if (!c) {\n          break;\n        }\n\n        if (parser.trackPosition) {\n          parser.position++;\n\n          if (c === '\\n') {\n            parser.line++;\n            parser.column = 0;\n          } else {\n            parser.column++;\n          }\n        }\n\n        switch (parser.state) {\n          case S.BEGIN:\n            parser.state = S.BEGIN_WHITESPACE;\n\n            if (c === '\\uFEFF') {\n              continue;\n            }\n\n            beginWhiteSpace(parser, c);\n            continue;\n\n          case S.BEGIN_WHITESPACE:\n            beginWhiteSpace(parser, c);\n            continue;\n\n          case S.TEXT:\n            if (parser.sawRoot && !parser.closedRoot) {\n              var starti = i - 1;\n\n              while (c && c !== '<' && c !== '&') {\n                c = charAt(chunk, i++);\n\n                if (c && parser.trackPosition) {\n                  parser.position++;\n\n                  if (c === '\\n') {\n                    parser.line++;\n                    parser.column = 0;\n                  } else {\n                    parser.column++;\n                  }\n                }\n              }\n\n              parser.textNode += chunk.substring(starti, i - 1);\n            }\n\n            if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n              parser.state = S.OPEN_WAKA;\n              parser.startTagPosition = parser.position;\n            } else {\n              if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n                strictFail(parser, 'Text data outside of root node.');\n              }\n\n              if (c === '&') {\n                parser.state = S.TEXT_ENTITY;\n              } else {\n                parser.textNode += c;\n              }\n            }\n\n            continue;\n\n          case S.SCRIPT:\n            // only non-strict\n            if (c === '<') {\n              parser.state = S.SCRIPT_ENDING;\n            } else {\n              parser.script += c;\n            }\n\n            continue;\n\n          case S.SCRIPT_ENDING:\n            if (c === '/') {\n              parser.state = S.CLOSE_TAG;\n            } else {\n              parser.script += '<' + c;\n              parser.state = S.SCRIPT;\n            }\n\n            continue;\n\n          case S.OPEN_WAKA:\n            // either a /, ?, !, or text is coming next.\n            if (c === '!') {\n              parser.state = S.SGML_DECL;\n              parser.sgmlDecl = '';\n            } else if (isWhitespace(c)) ;else if (isMatch(nameStart, c)) {\n              parser.state = S.OPEN_TAG;\n              parser.tagName = c;\n            } else if (c === '/') {\n              parser.state = S.CLOSE_TAG;\n              parser.tagName = '';\n            } else if (c === '?') {\n              parser.state = S.PROC_INST;\n              parser.procInstName = parser.procInstBody = '';\n            } else {\n              strictFail(parser, 'Unencoded <'); // if there was some whitespace, then add that in.\n\n              if (parser.startTagPosition + 1 < parser.position) {\n                var pad = parser.position - parser.startTagPosition;\n                c = new Array(pad).join(' ') + c;\n              }\n\n              parser.textNode += '<' + c;\n              parser.state = S.TEXT;\n            }\n\n            continue;\n\n          case S.SGML_DECL:\n            if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n              emitNode(parser, 'onopencdata');\n              parser.state = S.CDATA;\n              parser.sgmlDecl = '';\n              parser.cdata = '';\n            } else if (parser.sgmlDecl + c === '--') {\n              parser.state = S.COMMENT;\n              parser.comment = '';\n              parser.sgmlDecl = '';\n            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n              parser.state = S.DOCTYPE;\n\n              if (parser.doctype || parser.sawRoot) {\n                strictFail(parser, 'Inappropriately located doctype declaration');\n              }\n\n              parser.doctype = '';\n              parser.sgmlDecl = '';\n            } else if (c === '>') {\n              emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);\n              parser.sgmlDecl = '';\n              parser.state = S.TEXT;\n            } else if (isQuote(c)) {\n              parser.state = S.SGML_DECL_QUOTED;\n              parser.sgmlDecl += c;\n            } else {\n              parser.sgmlDecl += c;\n            }\n\n            continue;\n\n          case S.SGML_DECL_QUOTED:\n            if (c === parser.q) {\n              parser.state = S.SGML_DECL;\n              parser.q = '';\n            }\n\n            parser.sgmlDecl += c;\n            continue;\n\n          case S.DOCTYPE:\n            if (c === '>') {\n              parser.state = S.TEXT;\n              emitNode(parser, 'ondoctype', parser.doctype);\n              parser.doctype = true; // just remember that we saw it.\n            } else {\n              parser.doctype += c;\n\n              if (c === '[') {\n                parser.state = S.DOCTYPE_DTD;\n              } else if (isQuote(c)) {\n                parser.state = S.DOCTYPE_QUOTED;\n                parser.q = c;\n              }\n            }\n\n            continue;\n\n          case S.DOCTYPE_QUOTED:\n            parser.doctype += c;\n\n            if (c === parser.q) {\n              parser.q = '';\n              parser.state = S.DOCTYPE;\n            }\n\n            continue;\n\n          case S.DOCTYPE_DTD:\n            parser.doctype += c;\n\n            if (c === ']') {\n              parser.state = S.DOCTYPE;\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_DTD_QUOTED;\n              parser.q = c;\n            }\n\n            continue;\n\n          case S.DOCTYPE_DTD_QUOTED:\n            parser.doctype += c;\n\n            if (c === parser.q) {\n              parser.state = S.DOCTYPE_DTD;\n              parser.q = '';\n            }\n\n            continue;\n\n          case S.COMMENT:\n            if (c === '-') {\n              parser.state = S.COMMENT_ENDING;\n            } else {\n              parser.comment += c;\n            }\n\n            continue;\n\n          case S.COMMENT_ENDING:\n            if (c === '-') {\n              parser.state = S.COMMENT_ENDED;\n              parser.comment = textopts(parser.opt, parser.comment);\n\n              if (parser.comment) {\n                emitNode(parser, 'oncomment', parser.comment);\n              }\n\n              parser.comment = '';\n            } else {\n              parser.comment += '-' + c;\n              parser.state = S.COMMENT;\n            }\n\n            continue;\n\n          case S.COMMENT_ENDED:\n            if (c !== '>') {\n              strictFail(parser, 'Malformed comment'); // allow <!-- blah -- bloo --> in non-strict mode,\n              // which is a comment of \" blah -- bloo \"\n\n              parser.comment += '--' + c;\n              parser.state = S.COMMENT;\n            } else {\n              parser.state = S.TEXT;\n            }\n\n            continue;\n\n          case S.CDATA:\n            if (c === ']') {\n              parser.state = S.CDATA_ENDING;\n            } else {\n              parser.cdata += c;\n            }\n\n            continue;\n\n          case S.CDATA_ENDING:\n            if (c === ']') {\n              parser.state = S.CDATA_ENDING_2;\n            } else {\n              parser.cdata += ']' + c;\n              parser.state = S.CDATA;\n            }\n\n            continue;\n\n          case S.CDATA_ENDING_2:\n            if (c === '>') {\n              if (parser.cdata) {\n                emitNode(parser, 'oncdata', parser.cdata);\n              }\n\n              emitNode(parser, 'onclosecdata');\n              parser.cdata = '';\n              parser.state = S.TEXT;\n            } else if (c === ']') {\n              parser.cdata += ']';\n            } else {\n              parser.cdata += ']]' + c;\n              parser.state = S.CDATA;\n            }\n\n            continue;\n\n          case S.PROC_INST:\n            if (c === '?') {\n              parser.state = S.PROC_INST_ENDING;\n            } else if (isWhitespace(c)) {\n              parser.state = S.PROC_INST_BODY;\n            } else {\n              parser.procInstName += c;\n            }\n\n            continue;\n\n          case S.PROC_INST_BODY:\n            if (!parser.procInstBody && isWhitespace(c)) {\n              continue;\n            } else if (c === '?') {\n              parser.state = S.PROC_INST_ENDING;\n            } else {\n              parser.procInstBody += c;\n            }\n\n            continue;\n\n          case S.PROC_INST_ENDING:\n            if (c === '>') {\n              emitNode(parser, 'onprocessinginstruction', {\n                name: parser.procInstName,\n                body: parser.procInstBody\n              });\n              parser.procInstName = parser.procInstBody = '';\n              parser.state = S.TEXT;\n            } else {\n              parser.procInstBody += '?' + c;\n              parser.state = S.PROC_INST_BODY;\n            }\n\n            continue;\n\n          case S.OPEN_TAG:\n            if (isMatch(nameBody, c)) {\n              parser.tagName += c;\n            } else {\n              newTag(parser);\n\n              if (c === '>') {\n                openTag(parser);\n              } else if (c === '/') {\n                parser.state = S.OPEN_TAG_SLASH;\n              } else {\n                if (!isWhitespace(c)) {\n                  strictFail(parser, 'Invalid character in tag name');\n                }\n\n                parser.state = S.ATTRIB;\n              }\n            }\n\n            continue;\n\n          case S.OPEN_TAG_SLASH:\n            if (c === '>') {\n              openTag(parser, true);\n              closeTag(parser);\n            } else {\n              strictFail(parser, 'Forward-slash in opening tag not followed by >');\n              parser.state = S.ATTRIB;\n            }\n\n            continue;\n\n          case S.ATTRIB:\n            // haven't read the attribute name yet.\n            if (isWhitespace(c)) {\n              continue;\n            } else if (c === '>') {\n              openTag(parser);\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH;\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c;\n              parser.attribValue = '';\n              parser.state = S.ATTRIB_NAME;\n            } else {\n              strictFail(parser, 'Invalid attribute name');\n            }\n\n            continue;\n\n          case S.ATTRIB_NAME:\n            if (c === '=') {\n              parser.state = S.ATTRIB_VALUE;\n            } else if (c === '>') {\n              strictFail(parser, 'Attribute without value');\n              parser.attribValue = parser.attribName;\n              attrib(parser);\n              openTag(parser);\n            } else if (isWhitespace(c)) {\n              parser.state = S.ATTRIB_NAME_SAW_WHITE;\n            } else if (isMatch(nameBody, c)) {\n              parser.attribName += c;\n            } else {\n              strictFail(parser, 'Invalid attribute name');\n            }\n\n            continue;\n\n          case S.ATTRIB_NAME_SAW_WHITE:\n            if (c === '=') {\n              parser.state = S.ATTRIB_VALUE;\n            } else if (isWhitespace(c)) {\n              continue;\n            } else {\n              strictFail(parser, 'Attribute without value');\n              parser.tag.attributes[parser.attribName] = '';\n              parser.attribValue = '';\n              emitNode(parser, 'onattribute', {\n                name: parser.attribName,\n                value: ''\n              });\n              parser.attribName = '';\n\n              if (c === '>') {\n                openTag(parser);\n              } else if (isMatch(nameStart, c)) {\n                parser.attribName = c;\n                parser.state = S.ATTRIB_NAME;\n              } else {\n                strictFail(parser, 'Invalid attribute name');\n                parser.state = S.ATTRIB;\n              }\n            }\n\n            continue;\n\n          case S.ATTRIB_VALUE:\n            if (isWhitespace(c)) {\n              continue;\n            } else if (isQuote(c)) {\n              parser.q = c;\n              parser.state = S.ATTRIB_VALUE_QUOTED;\n            } else {\n              strictFail(parser, 'Unquoted attribute value');\n              parser.state = S.ATTRIB_VALUE_UNQUOTED;\n              parser.attribValue = c;\n            }\n\n            continue;\n\n          case S.ATTRIB_VALUE_QUOTED:\n            if (c !== parser.q) {\n              if (c === '&') {\n                parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n              } else {\n                parser.attribValue += c;\n              }\n\n              continue;\n            }\n\n            attrib(parser);\n            parser.q = '';\n            parser.state = S.ATTRIB_VALUE_CLOSED;\n            continue;\n\n          case S.ATTRIB_VALUE_CLOSED:\n            if (isWhitespace(c)) {\n              parser.state = S.ATTRIB;\n            } else if (c === '>') {\n              openTag(parser);\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH;\n            } else if (isMatch(nameStart, c)) {\n              strictFail(parser, 'No whitespace between attributes');\n              parser.attribName = c;\n              parser.attribValue = '';\n              parser.state = S.ATTRIB_NAME;\n            } else {\n              strictFail(parser, 'Invalid attribute name');\n            }\n\n            continue;\n\n          case S.ATTRIB_VALUE_UNQUOTED:\n            if (!isAttribEnd(c)) {\n              if (c === '&') {\n                parser.state = S.ATTRIB_VALUE_ENTITY_U;\n              } else {\n                parser.attribValue += c;\n              }\n\n              continue;\n            }\n\n            attrib(parser);\n\n            if (c === '>') {\n              openTag(parser);\n            } else {\n              parser.state = S.ATTRIB;\n            }\n\n            continue;\n\n          case S.CLOSE_TAG:\n            if (!parser.tagName) {\n              if (isWhitespace(c)) {\n                continue;\n              } else if (notMatch(nameStart, c)) {\n                if (parser.script) {\n                  parser.script += '</' + c;\n                  parser.state = S.SCRIPT;\n                } else {\n                  strictFail(parser, 'Invalid tagname in closing tag.');\n                }\n              } else {\n                parser.tagName = c;\n              }\n            } else if (c === '>') {\n              closeTag(parser);\n            } else if (isMatch(nameBody, c)) {\n              parser.tagName += c;\n            } else if (parser.script) {\n              parser.script += '</' + parser.tagName;\n              parser.tagName = '';\n              parser.state = S.SCRIPT;\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, 'Invalid tagname in closing tag');\n              }\n\n              parser.state = S.CLOSE_TAG_SAW_WHITE;\n            }\n\n            continue;\n\n          case S.CLOSE_TAG_SAW_WHITE:\n            if (isWhitespace(c)) {\n              continue;\n            }\n\n            if (c === '>') {\n              closeTag(parser);\n            } else {\n              strictFail(parser, 'Invalid characters in closing tag');\n            }\n\n            continue;\n\n          case S.TEXT_ENTITY:\n          case S.ATTRIB_VALUE_ENTITY_Q:\n          case S.ATTRIB_VALUE_ENTITY_U:\n            var returnState;\n            var buffer;\n\n            switch (parser.state) {\n              case S.TEXT_ENTITY:\n                returnState = S.TEXT;\n                buffer = 'textNode';\n                break;\n\n              case S.ATTRIB_VALUE_ENTITY_Q:\n                returnState = S.ATTRIB_VALUE_QUOTED;\n                buffer = 'attribValue';\n                break;\n\n              case S.ATTRIB_VALUE_ENTITY_U:\n                returnState = S.ATTRIB_VALUE_UNQUOTED;\n                buffer = 'attribValue';\n                break;\n            }\n\n            if (c === ';') {\n              parser[buffer] += parseEntity(parser);\n              parser.entity = '';\n              parser.state = returnState;\n            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n              parser.entity += c;\n            } else {\n              strictFail(parser, 'Invalid character in entity name');\n              parser[buffer] += '&' + parser.entity + c;\n              parser.entity = '';\n              parser.state = returnState;\n            }\n\n            continue;\n\n          default:\n            throw new Error(parser, 'Unknown state: ' + parser.state);\n        }\n      } // while\n\n\n      if (parser.position >= parser.bufferCheckPosition) {\n        checkBufferLength(parser);\n      }\n\n      return parser;\n    }\n    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n\n    /* istanbul ignore next */\n\n\n    if (!String.fromCodePoint) {\n      (function () {\n        var stringFromCharCode = String.fromCharCode;\n        var floor = Math.floor;\n\n        var fromCodePoint = function () {\n          var MAX_SIZE = 0x4000;\n          var codeUnits = [];\n          var highSurrogate;\n          var lowSurrogate;\n          var index = -1;\n          var length = arguments.length;\n\n          if (!length) {\n            return '';\n          }\n\n          var result = '';\n\n          while (++index < length) {\n            var codePoint = Number(arguments[index]);\n\n            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10FFFF || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n            ) {\n                throw RangeError('Invalid code point: ' + codePoint);\n              }\n\n            if (codePoint <= 0xFFFF) {\n              // BMP code point\n              codeUnits.push(codePoint);\n            } else {\n              // Astral code point; split in surrogate halves\n              // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n              codePoint -= 0x10000;\n              highSurrogate = (codePoint >> 10) + 0xD800;\n              lowSurrogate = codePoint % 0x400 + 0xDC00;\n              codeUnits.push(highSurrogate, lowSurrogate);\n            }\n\n            if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n              result += stringFromCharCode.apply(null, codeUnits);\n              codeUnits.length = 0;\n            }\n          }\n\n          return result;\n        };\n        /* istanbul ignore next */\n\n\n        if (Object.defineProperty) {\n          Object.defineProperty(String, 'fromCodePoint', {\n            value: fromCodePoint,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          String.fromCodePoint = fromCodePoint;\n        }\n      })();\n    }\n  })(exports);\n});\nvar arrayHelper = {\n  isArray: function (value) {\n    if (Array.isArray) {\n      return Array.isArray(value);\n    } // fallback for older browsers like  IE 8\n\n\n    return Object.prototype.toString.call(value) === '[object Array]';\n  }\n};\nvar isArray = arrayHelper.isArray;\nvar optionsHelper = {\n  copyOptions: function (options) {\n    var key,\n        copy = {};\n\n    for (key in options) {\n      if (options.hasOwnProperty(key)) {\n        copy[key] = options[key];\n      }\n    }\n\n    return copy;\n  },\n  ensureFlagExists: function (item, options) {\n    if (!(item in options) || typeof options[item] !== 'boolean') {\n      options[item] = false;\n    }\n  },\n  ensureSpacesExists: function (options) {\n    if (!('spaces' in options) || typeof options.spaces !== 'number' && typeof options.spaces !== 'string') {\n      options.spaces = 0;\n    }\n  },\n  ensureAlwaysArrayExists: function (options) {\n    if (!('alwaysArray' in options) || typeof options.alwaysArray !== 'boolean' && !isArray(options.alwaysArray)) {\n      options.alwaysArray = false;\n    }\n  },\n  ensureKeyExists: function (key, options) {\n    if (!(key + 'Key' in options) || typeof options[key + 'Key'] !== 'string') {\n      options[key + 'Key'] = options.compact ? '_' + key : key;\n    }\n  },\n  checkFnExists: function (key, options) {\n    return key + 'Fn' in options;\n  }\n};\nvar isArray$1 = arrayHelper.isArray;\nvar options;\nvar currentElement;\n\nfunction validateOptions(userOptions) {\n  options = optionsHelper.copyOptions(userOptions);\n  optionsHelper.ensureFlagExists('ignoreDeclaration', options);\n  optionsHelper.ensureFlagExists('ignoreInstruction', options);\n  optionsHelper.ensureFlagExists('ignoreAttributes', options);\n  optionsHelper.ensureFlagExists('ignoreText', options);\n  optionsHelper.ensureFlagExists('ignoreComment', options);\n  optionsHelper.ensureFlagExists('ignoreCdata', options);\n  optionsHelper.ensureFlagExists('ignoreDoctype', options);\n  optionsHelper.ensureFlagExists('compact', options);\n  optionsHelper.ensureFlagExists('alwaysChildren', options);\n  optionsHelper.ensureFlagExists('addParent', options);\n  optionsHelper.ensureFlagExists('trim', options);\n  optionsHelper.ensureFlagExists('nativeType', options);\n  optionsHelper.ensureFlagExists('nativeTypeAttributes', options);\n  optionsHelper.ensureFlagExists('sanitize', options);\n  optionsHelper.ensureFlagExists('instructionHasAttributes', options);\n  optionsHelper.ensureFlagExists('captureSpacesBetweenElements', options);\n  optionsHelper.ensureAlwaysArrayExists(options);\n  optionsHelper.ensureKeyExists('declaration', options);\n  optionsHelper.ensureKeyExists('instruction', options);\n  optionsHelper.ensureKeyExists('attributes', options);\n  optionsHelper.ensureKeyExists('text', options);\n  optionsHelper.ensureKeyExists('comment', options);\n  optionsHelper.ensureKeyExists('cdata', options);\n  optionsHelper.ensureKeyExists('doctype', options);\n  optionsHelper.ensureKeyExists('type', options);\n  optionsHelper.ensureKeyExists('name', options);\n  optionsHelper.ensureKeyExists('elements', options);\n  optionsHelper.ensureKeyExists('parent', options);\n  return options;\n}\n\nfunction nativeType(value) {\n  var nValue = Number(value);\n\n  if (!isNaN(nValue)) {\n    return nValue;\n  }\n\n  var bValue = value.toLowerCase();\n\n  if (bValue === 'true') {\n    return true;\n  } else if (bValue === 'false') {\n    return false;\n  }\n\n  return value;\n}\n\nfunction addField(type, value) {\n  var key;\n\n  if (options.compact) {\n    if (!currentElement[options[type + 'Key']] && (isArray$1(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + 'Key']) !== -1 : options.alwaysArray)) {\n      currentElement[options[type + 'Key']] = [];\n    }\n\n    if (currentElement[options[type + 'Key']] && !isArray$1(currentElement[options[type + 'Key']])) {\n      currentElement[options[type + 'Key']] = [currentElement[options[type + 'Key']]];\n    }\n\n    if (type + 'Fn' in options && typeof value === 'string') {\n      value = options[type + 'Fn'](value, currentElement);\n    }\n\n    if (type === 'instruction' && ('instructionFn' in options || 'instructionNameFn' in options)) {\n      for (key in value) {\n        if (value.hasOwnProperty(key)) {\n          if ('instructionFn' in options) {\n            value[key] = options.instructionFn(value[key], key, currentElement);\n          } else {\n            var temp = value[key];\n            delete value[key];\n            value[options.instructionNameFn(key, temp, currentElement)] = temp;\n          }\n        }\n      }\n    }\n\n    if (isArray$1(currentElement[options[type + 'Key']])) {\n      currentElement[options[type + 'Key']].push(value);\n    } else {\n      currentElement[options[type + 'Key']] = value;\n    }\n  } else {\n    if (!currentElement[options.elementsKey]) {\n      currentElement[options.elementsKey] = [];\n    }\n\n    var element = {};\n    element[options.typeKey] = type;\n\n    if (type === 'instruction') {\n      for (key in value) {\n        if (value.hasOwnProperty(key)) {\n          break;\n        }\n      }\n\n      element[options.nameKey] = 'instructionNameFn' in options ? options.instructionNameFn(key, value, currentElement) : key;\n\n      if (options.instructionHasAttributes) {\n        element[options.attributesKey] = value[key][options.attributesKey];\n\n        if ('instructionFn' in options) {\n          element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);\n        }\n      } else {\n        if ('instructionFn' in options) {\n          value[key] = options.instructionFn(value[key], key, currentElement);\n        }\n\n        element[options.instructionKey] = value[key];\n      }\n    } else {\n      if (type + 'Fn' in options) {\n        value = options[type + 'Fn'](value, currentElement);\n      }\n\n      element[options[type + 'Key']] = value;\n    }\n\n    if (options.addParent) {\n      element[options.parentKey] = currentElement;\n    }\n\n    currentElement[options.elementsKey].push(element);\n  }\n}\n\nfunction manipulateAttributes(attributes) {\n  if ('attributesFn' in options && attributes) {\n    attributes = options.attributesFn(attributes, currentElement);\n  }\n\n  if ((options.trim || 'attributeValueFn' in options || 'attributeNameFn' in options || options.nativeTypeAttributes) && attributes) {\n    var key;\n\n    for (key in attributes) {\n      if (attributes.hasOwnProperty(key)) {\n        if (options.trim) attributes[key] = attributes[key].trim();\n\n        if (options.nativeTypeAttributes) {\n          attributes[key] = nativeType(attributes[key]);\n        }\n\n        if ('attributeValueFn' in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);\n\n        if ('attributeNameFn' in options) {\n          var temp = attributes[key];\n          delete attributes[key];\n          attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;\n        }\n      }\n    }\n  }\n\n  return attributes;\n}\n\nfunction onInstruction(instruction) {\n  var attributes = {};\n\n  if (instruction.body && (instruction.name.toLowerCase() === 'xml' || options.instructionHasAttributes)) {\n    var attrsRegExp = /([\\w:-]+)\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\w+))\\s*/g;\n    var match;\n\n    while ((match = attrsRegExp.exec(instruction.body)) !== null) {\n      attributes[match[1]] = match[2] || match[3] || match[4];\n    }\n\n    attributes = manipulateAttributes(attributes);\n  }\n\n  if (instruction.name.toLowerCase() === 'xml') {\n    if (options.ignoreDeclaration) {\n      return;\n    }\n\n    currentElement[options.declarationKey] = {};\n\n    if (Object.keys(attributes).length) {\n      currentElement[options.declarationKey][options.attributesKey] = attributes;\n    }\n\n    if (options.addParent) {\n      currentElement[options.declarationKey][options.parentKey] = currentElement;\n    }\n  } else {\n    if (options.ignoreInstruction) {\n      return;\n    }\n\n    if (options.trim) {\n      instruction.body = instruction.body.trim();\n    }\n\n    var value = {};\n\n    if (options.instructionHasAttributes && Object.keys(attributes).length) {\n      value[instruction.name] = {};\n      value[instruction.name][options.attributesKey] = attributes;\n    } else {\n      value[instruction.name] = instruction.body;\n    }\n\n    addField('instruction', value);\n  }\n}\n\nfunction onStartElement(name, attributes) {\n  var element;\n\n  if (typeof name === 'object') {\n    attributes = name.attributes;\n    name = name.name;\n  }\n\n  attributes = manipulateAttributes(attributes);\n\n  if ('elementNameFn' in options) {\n    name = options.elementNameFn(name, currentElement);\n  }\n\n  if (options.compact) {\n    element = {};\n\n    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {\n      element[options.attributesKey] = {};\n      var key;\n\n      for (key in attributes) {\n        if (attributes.hasOwnProperty(key)) {\n          element[options.attributesKey][key] = attributes[key];\n        }\n      }\n    }\n\n    if (!(name in currentElement) && (isArray$1(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)) {\n      currentElement[name] = [];\n    }\n\n    if (currentElement[name] && !isArray$1(currentElement[name])) {\n      currentElement[name] = [currentElement[name]];\n    }\n\n    if (isArray$1(currentElement[name])) {\n      currentElement[name].push(element);\n    } else {\n      currentElement[name] = element;\n    }\n  } else {\n    if (!currentElement[options.elementsKey]) {\n      currentElement[options.elementsKey] = [];\n    }\n\n    element = {};\n    element[options.typeKey] = 'element';\n    element[options.nameKey] = name;\n\n    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {\n      element[options.attributesKey] = attributes;\n    }\n\n    if (options.alwaysChildren) {\n      element[options.elementsKey] = [];\n    }\n\n    currentElement[options.elementsKey].push(element);\n  }\n\n  element[options.parentKey] = currentElement; // will be deleted in onEndElement() if !options.addParent\n\n  currentElement = element;\n}\n\nfunction onText(text) {\n  if (options.ignoreText) {\n    return;\n  }\n\n  if (!text.trim() && !options.captureSpacesBetweenElements) {\n    return;\n  }\n\n  if (options.trim) {\n    text = text.trim();\n  }\n\n  if (options.nativeType) {\n    text = nativeType(text);\n  }\n\n  if (options.sanitize) {\n    text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n  }\n\n  addField('text', text);\n}\n\nfunction onComment(comment) {\n  if (options.ignoreComment) {\n    return;\n  }\n\n  if (options.trim) {\n    comment = comment.trim();\n  }\n\n  addField('comment', comment);\n}\n\nfunction onEndElement(name) {\n  var parentElement = currentElement[options.parentKey];\n\n  if (!options.addParent) {\n    delete currentElement[options.parentKey];\n  }\n\n  currentElement = parentElement;\n}\n\nfunction onCdata(cdata) {\n  if (options.ignoreCdata) {\n    return;\n  }\n\n  if (options.trim) {\n    cdata = cdata.trim();\n  }\n\n  addField('cdata', cdata);\n}\n\nfunction onDoctype(doctype) {\n  if (options.ignoreDoctype) {\n    return;\n  }\n\n  doctype = doctype.replace(/^ /, '');\n\n  if (options.trim) {\n    doctype = doctype.trim();\n  }\n\n  addField('doctype', doctype);\n}\n\nfunction onError(error) {\n  error.note = error; //console.error(error);\n}\n\nvar xml2js = function (xml, userOptions) {\n  var parser = sax.parser(true, {});\n  var result = {};\n  currentElement = result;\n  options = validateOptions(userOptions);\n  {\n    parser.opt = {\n      strictEntities: true\n    };\n    parser.onopentag = onStartElement;\n    parser.ontext = onText;\n    parser.oncomment = onComment;\n    parser.onclosetag = onEndElement;\n    parser.onerror = onError;\n    parser.oncdata = onCdata;\n    parser.ondoctype = onDoctype;\n    parser.onprocessinginstruction = onInstruction;\n  }\n  {\n    parser.write(xml).close();\n  }\n\n  if (result[options.elementsKey]) {\n    var temp = result[options.elementsKey];\n    delete result[options.elementsKey];\n    result[options.elementsKey] = temp;\n    delete result.text;\n  }\n\n  return result;\n};\n\nfunction validateOptions$1(userOptions) {\n  var options = optionsHelper.copyOptions(userOptions);\n  optionsHelper.ensureSpacesExists(options);\n  return options;\n}\n\nvar xml2json = function (xml, userOptions) {\n  var options, js, json, parentKey;\n  options = validateOptions$1(userOptions);\n  js = xml2js(xml, options);\n  parentKey = 'compact' in options && options.compact ? '_parent' : 'parent'; // parentKey = ptions.compact ? '_parent' : 'parent'; // consider this\n\n  if ('addParent' in options && options.addParent) {\n    json = JSON.stringify(js, function (k, v) {\n      return k === parentKey ? '_' : v;\n    }, options.spaces);\n  } else {\n    json = JSON.stringify(js, null, options.spaces);\n  }\n\n  return json.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n};\n\nvar isArray$2 = arrayHelper.isArray;\nvar currentElement$1, currentElementName;\n\nfunction validateOptions$2(userOptions) {\n  var options = optionsHelper.copyOptions(userOptions);\n  optionsHelper.ensureFlagExists('ignoreDeclaration', options);\n  optionsHelper.ensureFlagExists('ignoreInstruction', options);\n  optionsHelper.ensureFlagExists('ignoreAttributes', options);\n  optionsHelper.ensureFlagExists('ignoreText', options);\n  optionsHelper.ensureFlagExists('ignoreComment', options);\n  optionsHelper.ensureFlagExists('ignoreCdata', options);\n  optionsHelper.ensureFlagExists('ignoreDoctype', options);\n  optionsHelper.ensureFlagExists('compact', options);\n  optionsHelper.ensureFlagExists('indentText', options);\n  optionsHelper.ensureFlagExists('indentCdata', options);\n  optionsHelper.ensureFlagExists('indentAttributes', options);\n  optionsHelper.ensureFlagExists('indentInstruction', options);\n  optionsHelper.ensureFlagExists('fullTagEmptyElement', options);\n  optionsHelper.ensureFlagExists('noQuotesForNativeAttributes', options);\n  optionsHelper.ensureSpacesExists(options);\n\n  if (typeof options.spaces === 'number') {\n    options.spaces = Array(options.spaces + 1).join(' ');\n  }\n\n  optionsHelper.ensureKeyExists('declaration', options);\n  optionsHelper.ensureKeyExists('instruction', options);\n  optionsHelper.ensureKeyExists('attributes', options);\n  optionsHelper.ensureKeyExists('text', options);\n  optionsHelper.ensureKeyExists('comment', options);\n  optionsHelper.ensureKeyExists('cdata', options);\n  optionsHelper.ensureKeyExists('doctype', options);\n  optionsHelper.ensureKeyExists('type', options);\n  optionsHelper.ensureKeyExists('name', options);\n  optionsHelper.ensureKeyExists('elements', options);\n  return options;\n}\n\nfunction writeIndentation(options, depth, firstLine) {\n  return (!firstLine && options.spaces ? '\\n' : '') + Array(depth + 1).join(options.spaces);\n}\n\nfunction writeAttributes(attributes, options, depth) {\n  if (options.ignoreAttributes) {\n    return '';\n  }\n\n  if ('attributesFn' in options) {\n    attributes = options.attributesFn(attributes, currentElementName, currentElement$1);\n  }\n\n  var key,\n      attr,\n      attrName,\n      quote,\n      result = [];\n\n  for (key in attributes) {\n    if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== undefined) {\n      quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== 'string' ? '' : '\"';\n      attr = '' + attributes[key]; // ensure number and boolean are converted to String\n\n      attr = attr.replace(/\"/g, '&quot;');\n      attrName = 'attributeNameFn' in options ? options.attributeNameFn(key, attr, currentElementName, currentElement$1) : key;\n      result.push(options.spaces && options.indentAttributes ? writeIndentation(options, depth + 1, false) : ' ');\n      result.push(attrName + '=' + quote + ('attributeValueFn' in options ? options.attributeValueFn(attr, key, currentElementName, currentElement$1) : attr) + quote);\n    }\n  }\n\n  if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {\n    result.push(writeIndentation(options, depth, false));\n  }\n\n  return result.join('');\n}\n\nfunction writeDeclaration(declaration, options, depth) {\n  currentElement$1 = declaration;\n  currentElementName = 'xml';\n  return options.ignoreDeclaration ? '' : '<?' + 'xml' + writeAttributes(declaration[options.attributesKey], options, depth) + '?>';\n}\n\nfunction writeInstruction(instruction, options, depth) {\n  if (options.ignoreInstruction) {\n    return '';\n  }\n\n  var key;\n\n  for (key in instruction) {\n    if (instruction.hasOwnProperty(key)) {\n      break;\n    }\n  }\n\n  var instructionName = 'instructionNameFn' in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement$1) : key;\n\n  if (typeof instruction[key] === 'object') {\n    currentElement$1 = instruction;\n    currentElementName = instructionName;\n    return '<?' + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + '?>';\n  } else {\n    var instructionValue = instruction[key] ? instruction[key] : '';\n    if ('instructionFn' in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement$1);\n    return '<?' + instructionName + (instructionValue ? ' ' + instructionValue : '') + '?>';\n  }\n}\n\nfunction writeComment(comment, options) {\n  return options.ignoreComment ? '' : '<!--' + ('commentFn' in options ? options.commentFn(comment, currentElementName, currentElement$1) : comment) + '-->';\n}\n\nfunction writeCdata(cdata, options) {\n  return options.ignoreCdata ? '' : '<![CDATA[' + ('cdataFn' in options ? options.cdataFn(cdata, currentElementName, currentElement$1) : cdata.replace(']]>', ']]]]><![CDATA[>')) + ']]>';\n}\n\nfunction writeDoctype(doctype, options) {\n  return options.ignoreDoctype ? '' : '<!DOCTYPE ' + ('doctypeFn' in options ? options.doctypeFn(doctype, currentElementName, currentElement$1) : doctype) + '>';\n}\n\nfunction writeText(text, options) {\n  if (options.ignoreText) return '';\n  text = '' + text; // ensure Number and Boolean are converted to String\n\n  text = text.replace(/&amp;/g, '&'); // desanitize to avoid double sanitization\n\n  text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n  return 'textFn' in options ? options.textFn(text, currentElementName, currentElement$1) : text;\n}\n\nfunction hasContent(element, options) {\n  var i;\n\n  if (element.elements && element.elements.length) {\n    for (i = 0; i < element.elements.length; ++i) {\n      switch (element.elements[i][options.typeKey]) {\n        case 'text':\n          if (options.indentText) {\n            return true;\n          }\n\n          break;\n        // skip to next key\n\n        case 'cdata':\n          if (options.indentCdata) {\n            return true;\n          }\n\n          break;\n        // skip to next key\n\n        case 'instruction':\n          if (options.indentInstruction) {\n            return true;\n          }\n\n          break;\n        // skip to next key\n\n        case 'doctype':\n        case 'comment':\n        case 'element':\n          return true;\n\n        default:\n          return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction writeElement(element, options, depth) {\n  currentElement$1 = element;\n  currentElementName = element.name;\n  var xml = [],\n      elementName = 'elementNameFn' in options ? options.elementNameFn(element.name, element) : element.name;\n  xml.push('<' + elementName);\n\n  if (element[options.attributesKey]) {\n    xml.push(writeAttributes(element[options.attributesKey], options, depth));\n  }\n\n  var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';\n\n  if (!withClosingTag) {\n    if ('fullTagEmptyElementFn' in options) {\n      withClosingTag = options.fullTagEmptyElementFn(element.name, element);\n    } else {\n      withClosingTag = options.fullTagEmptyElement;\n    }\n  }\n\n  if (withClosingTag) {\n    xml.push('>');\n\n    if (element[options.elementsKey] && element[options.elementsKey].length) {\n      xml.push(writeElements(element[options.elementsKey], options, depth + 1));\n      currentElement$1 = element;\n      currentElementName = element.name;\n    }\n\n    xml.push(options.spaces && hasContent(element, options) ? '\\n' + Array(depth + 1).join(options.spaces) : '');\n    xml.push('</' + elementName + '>');\n  } else {\n    xml.push('/>');\n  }\n\n  return xml.join('');\n}\n\nfunction writeElements(elements, options, depth, firstLine) {\n  return elements.reduce(function (xml, element) {\n    var indent = writeIndentation(options, depth, firstLine && !xml);\n\n    switch (element.type) {\n      case 'element':\n        return xml + indent + writeElement(element, options, depth);\n\n      case 'comment':\n        return xml + indent + writeComment(element[options.commentKey], options);\n\n      case 'doctype':\n        return xml + indent + writeDoctype(element[options.doctypeKey], options);\n\n      case 'cdata':\n        return xml + (options.indentCdata ? indent : '') + writeCdata(element[options.cdataKey], options);\n\n      case 'text':\n        return xml + (options.indentText ? indent : '') + writeText(element[options.textKey], options);\n\n      case 'instruction':\n        var instruction = {};\n        instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];\n        return xml + (options.indentInstruction ? indent : '') + writeInstruction(instruction, options, depth);\n    }\n  }, '');\n}\n\nfunction hasContentCompact(element, options, anyContent) {\n  var key;\n\n  for (key in element) {\n    if (element.hasOwnProperty(key)) {\n      switch (key) {\n        case options.parentKey:\n        case options.attributesKey:\n          break;\n        // skip to next key\n\n        case options.textKey:\n          if (options.indentText || anyContent) {\n            return true;\n          }\n\n          break;\n        // skip to next key\n\n        case options.cdataKey:\n          if (options.indentCdata || anyContent) {\n            return true;\n          }\n\n          break;\n        // skip to next key\n\n        case options.instructionKey:\n          if (options.indentInstruction || anyContent) {\n            return true;\n          }\n\n          break;\n        // skip to next key\n\n        case options.doctypeKey:\n        case options.commentKey:\n          return true;\n\n        default:\n          return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction writeElementCompact(element, name, options, depth, indent) {\n  currentElement$1 = element;\n  currentElementName = name;\n  var elementName = 'elementNameFn' in options ? options.elementNameFn(name, element) : name;\n\n  if (typeof element === 'undefined' || element === null || element === '') {\n    return 'fullTagEmptyElementFn' in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? '<' + elementName + '></' + elementName + '>' : '<' + elementName + '/>';\n  }\n\n  var xml = [];\n\n  if (name) {\n    xml.push('<' + elementName);\n\n    if (typeof element !== 'object') {\n      xml.push('>' + writeText(element, options) + '</' + elementName + '>');\n      return xml.join('');\n    }\n\n    if (element[options.attributesKey]) {\n      xml.push(writeAttributes(element[options.attributesKey], options, depth));\n    }\n\n    var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';\n\n    if (!withClosingTag) {\n      if ('fullTagEmptyElementFn' in options) {\n        withClosingTag = options.fullTagEmptyElementFn(name, element);\n      } else {\n        withClosingTag = options.fullTagEmptyElement;\n      }\n    }\n\n    if (withClosingTag) {\n      xml.push('>');\n    } else {\n      xml.push('/>');\n      return xml.join('');\n    }\n  }\n\n  xml.push(writeElementsCompact(element, options, depth + 1, false));\n  currentElement$1 = element;\n  currentElementName = name;\n\n  if (name) {\n    xml.push((indent ? writeIndentation(options, depth, false) : '') + '</' + elementName + '>');\n  }\n\n  return xml.join('');\n}\n\nfunction writeElementsCompact(element, options, depth, firstLine) {\n  var i,\n      key,\n      nodes,\n      xml = [];\n\n  for (key in element) {\n    if (element.hasOwnProperty(key)) {\n      nodes = isArray$2(element[key]) ? element[key] : [element[key]];\n\n      for (i = 0; i < nodes.length; ++i) {\n        switch (key) {\n          case options.declarationKey:\n            xml.push(writeDeclaration(nodes[i], options, depth));\n            break;\n\n          case options.instructionKey:\n            xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : '') + writeInstruction(nodes[i], options, depth));\n            break;\n\n          case options.attributesKey:\n          case options.parentKey:\n            break;\n          // skip\n\n          case options.textKey:\n            xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : '') + writeText(nodes[i], options));\n            break;\n\n          case options.cdataKey:\n            xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : '') + writeCdata(nodes[i], options));\n            break;\n\n          case options.doctypeKey:\n            xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options));\n            break;\n\n          case options.commentKey:\n            xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options));\n            break;\n\n          default:\n            xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));\n        }\n\n        firstLine = firstLine && !xml.length;\n      }\n    }\n  }\n\n  return xml.join('');\n}\n\nvar js2xml = function (js, options) {\n  options = validateOptions$2(options);\n  var xml = [];\n  currentElement$1 = js;\n  currentElementName = '_root_';\n\n  if (options.compact) {\n    xml.push(writeElementsCompact(js, options, 0, true));\n  } else {\n    if (js[options.declarationKey]) {\n      xml.push(writeDeclaration(js[options.declarationKey], options, 0));\n    }\n\n    if (js[options.elementsKey] && js[options.elementsKey].length) {\n      xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length));\n    }\n  }\n\n  return xml.join('');\n};\n\nvar json2xml = function (json, options) {\n  if (json instanceof Buffer) {\n    json = json.toString();\n  }\n\n  var js = null;\n\n  if (typeof json === 'string') {\n    try {\n      js = JSON.parse(json);\n    } catch (e) {\n      throw new Error('The JSON structure is invalid');\n    }\n  } else {\n    js = json;\n  }\n\n  return js2xml(js, options);\n};\n/*jslint node:true */\n\n\nvar lib = {\n  xml2js: xml2js,\n  xml2json: xml2json,\n  js2xml: js2xml,\n  json2xml: json2xml\n};\n\nvar Attributes = function Attributes(_ref) {\n  var attributes = _ref.attributes,\n      theme = _ref.theme;\n  var attributeList = [];\n  var overflow = theme.overflowBreak ? {\n    overflowWrap: 'break-word',\n    whiteSpace: 'normal'\n  } : {};\n\n  for (var key in attributes) {\n    attributeList.push(React.createElement('span', {\n      key: 'attr-' + key + '[' + attributes[key] + ']'\n    }, React.createElement('span', {\n      style: {\n        color: theme.attributeKeyColor\n      }\n    }, ' ' + key), React.createElement('span', {\n      style: {\n        color: theme.separatorColor\n      }\n    }, \"=\"), React.createElement('span', {\n      style: {\n        color: theme.attributeValueColor\n      }\n    }, '\"' + attributes[key] + '\"')));\n  }\n\n  return React.createElement('span', {\n    style: overflow\n  }, attributeList);\n};\n\nAttributes.propTypes = {\n  attributes: PropTypes.object,\n  theme: PropTypes.object.isRequired\n};\n\nvar DeclarationElement = function DeclarationElement(_ref) {\n  var attributes = _ref.attributes,\n      theme = _ref.theme;\n  return React.createElement('div', null, React.createElement('span', {\n    style: {\n      color: theme.separatorColor\n    }\n  }, '<?'), React.createElement('span', {\n    style: {\n      color: theme.tagColor\n    }\n  }, \"xml\"), React.createElement(Attributes, {\n    attributes: attributes,\n    theme: theme\n  }), React.createElement('span', {\n    style: {\n      color: theme.separatorColor\n    }\n  }, '?>'));\n};\n\nDeclarationElement.propTypes = {\n  attributes: PropTypes.object.isRequired,\n  theme: PropTypes.object.isRequired\n};\n\nvar CdataElement = function CdataElement(_ref) {\n  var cdata = _ref.cdata,\n      theme = _ref.theme,\n      indentation = _ref.indentation;\n  return React.createElement('div', {\n    style: {\n      color: theme.cdataColor\n    }\n  }, indentation + '<![CDATA[' + cdata + ']]>');\n};\n\nCdataElement.propTypes = {\n  cdata: PropTypes.string.isRequired,\n  theme: PropTypes.object.isRequired,\n  indentation: PropTypes.string.isRequired\n};\n\nvar CommentElement = function CommentElement(_ref) {\n  var comment = _ref.comment,\n      theme = _ref.theme,\n      indentation = _ref.indentation;\n  return React.createElement('div', {\n    style: {\n      color: theme.commentColor\n    }\n  }, indentation + '<!-- ' + comment + ' -->');\n};\n\nCommentElement.propTypes = {\n  comment: PropTypes.string.isRequired,\n  theme: PropTypes.object.isRequired,\n  indentation: PropTypes.string.isRequired\n};\n\nvar InstructionElement = function InstructionElement(_ref) {\n  var name = _ref.name,\n      instruction = _ref.instruction,\n      theme = _ref.theme,\n      indentation = _ref.indentation;\n  return React.createElement('div', null, React.createElement('span', {\n    style: {\n      color: theme.separatorColor\n    }\n  }, indentation + '<?'), React.createElement('span', {\n    style: {\n      color: theme.tagColor\n    }\n  }, name), React.createElement('span', {\n    style: {\n      color: theme.attributeKeyColor\n    }\n  }, ' ' + instruction), React.createElement('span', {\n    style: {\n      color: theme.separatorColor\n    }\n  }, '?>'));\n};\n\nInstructionElement.propTypes = {\n  name: PropTypes.string.isRequired,\n  instruction: PropTypes.string.isRequired,\n  theme: PropTypes.object.isRequired,\n  indentation: PropTypes.string.isRequired\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar TextElement = function TextElement(_ref) {\n  var text = _ref.text,\n      theme = _ref.theme;\n  var overflow = theme.overflowBreak ? {\n    overflowWrap: 'break-word',\n    whiteSpace: 'normal'\n  } : {};\n  return React.createElement('span', {\n    style: _extends({\n      color: theme.textColor\n    }, overflow)\n  }, text);\n};\n\nTextElement.propTypes = {\n  text: PropTypes.string.isRequired,\n  theme: PropTypes.object.isRequired\n};\n\nfunction getIndentationString(size) {\n  return new Array(size + 1).join(\" \");\n}\n\nfunction isTextElement(elements) {\n  return elements.length === 1 && elements[0].type === \"text\";\n}\n\nvar Element = function Element(_ref) {\n  var name = _ref.name,\n      elements = _ref.elements,\n      attributes = _ref.attributes,\n      theme = _ref.theme,\n      indentation = _ref.indentation,\n      indentSize = _ref.indentSize;\n  return React.createElement('div', {\n    style: {\n      whiteSpace: 'pre'\n    }\n  }, React.createElement('span', {\n    style: {\n      color: theme.separatorColor\n    }\n  }, indentation + '<'), React.createElement('span', {\n    style: {\n      color: theme.tagColor\n    }\n  }, name), React.createElement(Attributes, {\n    attributes: attributes,\n    theme: theme\n  }), React.createElement('span', {\n    style: {\n      color: theme.separatorColor\n    }\n  }, elements ? '>' : '/>'), elements && React.createElement(Elements, {\n    elements: elements,\n    theme: theme,\n    indentation: indentation + getIndentationString(indentSize),\n    indentSize: indentSize\n  }), elements && React.createElement('span', {\n    style: {\n      color: theme.separatorColor\n    }\n  }, (isTextElement(elements) ? \"\" : indentation) + '</'), elements && React.createElement('span', {\n    style: {\n      color: theme.tagColor\n    }\n  }, name), elements && React.createElement('span', {\n    style: {\n      color: theme.separatorColor\n    }\n  }, \">\"));\n};\n\nElement.propTypes = {\n  name: PropTypes.string.isRequired,\n  elements: PropTypes.arrayOf(PropTypes.object),\n  attributes: PropTypes.object,\n  theme: PropTypes.object.isRequired,\n  indentation: PropTypes.string.isRequired,\n  indentSize: PropTypes.number.isRequired\n};\n\nvar getElement = function getElement(theme, indentation, indentSize) {\n  return function (element, index) {\n    switch (element.type) {\n      case \"text\":\n        return React.createElement(TextElement, {\n          key: 'el-' + index,\n          text: element.text,\n          theme: theme\n        });\n\n      case \"element\":\n        return React.createElement(Element, {\n          key: 'el-' + index,\n          name: element.name,\n          elements: element.elements,\n          attributes: element.attributes,\n          theme: theme,\n          indentation: indentation,\n          indentSize: indentSize\n        });\n\n      case \"comment\":\n        return React.createElement(CommentElement, {\n          key: 'el-' + index,\n          comment: element.comment,\n          theme: theme,\n          indentation: indentation\n        });\n\n      case \"cdata\":\n        return React.createElement(CdataElement, {\n          key: 'el-' + index,\n          cdata: element.cdata,\n          theme: theme,\n          indentation: indentation\n        });\n\n      case \"instruction\":\n        return React.createElement(InstructionElement, {\n          key: 'el-' + index,\n          instruction: element.instruction,\n          name: element.name,\n          theme: theme,\n          indentation: indentation\n        });\n\n      default:\n        return null;\n    }\n  };\n};\n\nvar Elements = function Elements(_ref2) {\n  var elements = _ref2.elements,\n      theme = _ref2.theme,\n      indentation = _ref2.indentation,\n      indentSize = _ref2.indentSize;\n  return elements.map(getElement(theme, indentation, indentSize));\n};\n\nElements.propTypes = {\n  elements: PropTypes.arrayOf(PropTypes.object),\n  theme: PropTypes.object.isRequired,\n  indentation: PropTypes.string.isRequired,\n  indentSize: PropTypes.number.isRequired\n};\nvar defaultTheme = {\n  tagColor: '#d43900',\n  textColor: '#333',\n  attributeKeyColor: '#2a7ab0',\n  attributeValueColor: '#008000',\n  separatorColor: '#333',\n  commentColor: '#aaa',\n  cdataColor: '#1d781d',\n  overflowBreak: false\n};\nvar defaultInvalidXml = React.createElement('div', null, 'Invalid XML!');\n\nvar XMLViewer = function XMLViewer(_ref) {\n  var xml = _ref.xml,\n      theme = _ref.theme,\n      indentSize = _ref.indentSize,\n      invalidXml = _ref.invalidXml,\n      props = objectWithoutProperties(_ref, ['xml', 'theme', 'indentSize', 'invalidXml']);\n  var json = null;\n\n  var customTheme = _extends({}, defaultTheme, theme);\n\n  try {\n    json = lib.xml2js(xml, {\n      compact: false,\n      spaces: 0\n    });\n\n    if (!Array.isArray(json.elements)) {\n      return invalidXml;\n    }\n  } catch (e) {\n    return invalidXml;\n  }\n\n  return React.createElement('div', props, json.declaration && React.createElement(DeclarationElement, {\n    theme: customTheme,\n    attributes: json.declaration.attributes\n  }), React.createElement(Elements, {\n    elements: json.elements,\n    theme: customTheme,\n    indentSize: indentSize,\n    indentation: ''\n  }));\n};\n\nXMLViewer.propTypes = {\n  xml: PropTypes.string.isRequired,\n  theme: PropTypes.object,\n  indentSize: PropTypes.number,\n  invalidXml: PropTypes.node\n};\nXMLViewer.defaultProps = {\n  theme: {},\n  indentSize: 2,\n  invalidXml: defaultInvalidXml\n};\nexport default XMLViewer;","map":{"version":3,"sources":["../node_modules/sax/lib/sax.js","../node_modules/xml-js/lib/array-helper.js","../node_modules/xml-js/lib/options-helper.js","../node_modules/xml-js/lib/xml2js.js","../node_modules/xml-js/lib/xml2json.js","../node_modules/xml-js/lib/js2xml.js","../node_modules/xml-js/lib/json2xml.js","../node_modules/xml-js/lib/index.js","../src/attributes.js","../src/declaration-el.js","../src/cdata-el.js","../src/comment-el.js","../src/instruction-el.js","../src/text-el.js","../src/elements.js","../src/index.js"],"names":["require$$0","require$$1","isArray","helper","validateOptions","currentElement","Attributes","attributes","theme","attributeList","overflow","overflowWrap","whiteSpace","color","key","PropTypes","isRequired","DeclarationElement","CdataElement","cdata","indentation","CommentElement","comment","InstructionElement","name","instruction","TextElement","text","size","elements","Element","indentSize","getIndentationString","isTextElement","getElement","element","Elements","defaultTheme","defaultInvalidXml","XMLViewer","xml","invalidXml","props","json","customTheme","convert","compact","spaces","Array","node"],"mappings":"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","sourcesContent":[";(function (sax) { // wrapper for non-node envs\n  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\n  sax.SAXParser = SAXParser\n  sax.SAXStream = SAXStream\n  sax.createStream = createStream\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024\n\n  var buffers = [\n    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',\n    'procInstName', 'procInstBody', 'entity', 'attribName',\n    'attribValue', 'cdata', 'script'\n  ]\n\n  sax.EVENTS = [\n    'text',\n    'processinginstruction',\n    'sgmldeclaration',\n    'doctype',\n    'comment',\n    'opentagstart',\n    'attribute',\n    'opentag',\n    'closetag',\n    'opencdata',\n    'cdata',\n    'closecdata',\n    'error',\n    'end',\n    'ready',\n    'script',\n    'opennamespace',\n    'closenamespace'\n  ]\n\n  function SAXParser (strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt)\n    }\n\n    var parser = this\n    clearBuffers(parser)\n    parser.q = parser.c = ''\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n    parser.opt = opt || {}\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'\n    parser.tags = []\n    parser.closed = parser.closedRoot = parser.sawRoot = false\n    parser.tag = parser.error = null\n    parser.strict = !!strict\n    parser.noscript = !!(strict || parser.opt.noscript)\n    parser.state = S.BEGIN\n    parser.strictEntities = parser.opt.strictEntities\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)\n    parser.attribList = []\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS)\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0\n    }\n    emit(parser, 'onready')\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F () {}\n      F.prototype = o\n      var newf = new F()\n      return newf\n    }\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = []\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n      return a\n    }\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    var maxActual = 0\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case 'textNode':\n            closeText(parser)\n            break\n\n          case 'cdata':\n            emitNode(parser, 'oncdata', parser.cdata)\n            parser.cdata = ''\n            break\n\n          case 'script':\n            emitNode(parser, 'onscript', parser.script)\n            parser.script = ''\n            break\n\n          default:\n            error(parser, 'Max buffer length exceeded: ' + buffers[i])\n        }\n      }\n      maxActual = Math.max(maxActual, len)\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual\n    parser.bufferCheckPosition = m + parser.position\n  }\n\n  function clearBuffers (parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = ''\n    }\n  }\n\n  function flushBuffers (parser) {\n    closeText(parser)\n    if (parser.cdata !== '') {\n      emitNode(parser, 'oncdata', parser.cdata)\n      parser.cdata = ''\n    }\n    if (parser.script !== '') {\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () { end(this) },\n    write: write,\n    resume: function () { this.error = null; return this },\n    close: function () { return this.write(null) },\n    flush: function () { flushBuffers(this) }\n  }\n\n  var Stream\n  try {\n    Stream = require('stream').Stream\n  } catch (ex) {\n    Stream = function () {}\n  }\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== 'error' && ev !== 'end'\n  })\n\n  function createStream (strict, opt) {\n    return new SAXStream(strict, opt)\n  }\n\n  function SAXStream (strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt)\n    }\n\n    Stream.apply(this)\n\n    this._parser = new SAXParser(strict, opt)\n    this.writable = true\n    this.readable = true\n\n    var me = this\n\n    this._parser.onend = function () {\n      me.emit('end')\n    }\n\n    this._parser.onerror = function (er) {\n      me.emit('error', er)\n\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null\n    }\n\n    this._decoder = null\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, 'on' + ev, {\n        get: function () {\n          return me._parser['on' + ev]\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev)\n            me._parser['on' + ev] = h\n            return h\n          }\n          me.on(ev, h)\n        },\n        enumerable: true,\n        configurable: false\n      })\n    })\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  })\n\n  SAXStream.prototype.write = function (data) {\n    if (typeof Buffer === 'function' &&\n      typeof Buffer.isBuffer === 'function' &&\n      Buffer.isBuffer(data)) {\n      if (!this._decoder) {\n        var SD = require('string_decoder').StringDecoder\n        this._decoder = new SD('utf8')\n      }\n      data = this._decoder.write(data)\n    }\n\n    this._parser.write(data.toString())\n    this.emit('data', data)\n    return true\n  }\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk)\n    }\n    this._parser.end()\n    return true\n  }\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this\n    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser['on' + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)\n        args.splice(0, 0, ev)\n        me.emit.apply(me, args)\n      }\n    }\n\n    return Stream.prototype.on.call(me, ev, handler)\n  }\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var CDATA = '[CDATA['\n  var DOCTYPE = 'DOCTYPE'\n  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'\n  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n  var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  function isWhitespace (c) {\n    return c === ' ' || c === '\\n' || c === '\\r' || c === '\\t'\n  }\n\n  function isQuote (c) {\n    return c === '\"' || c === '\\''\n  }\n\n  function isAttribEnd (c) {\n    return c === '>' || isWhitespace(c)\n  }\n\n  function isMatch (regex, c) {\n    return regex.test(c)\n  }\n\n  function notMatch (regex, c) {\n    return !isMatch(regex, c)\n  }\n\n  var S = 0\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // <!--\n    COMMENT_ENDING: S++, // <!-- blah -\n    COMMENT_ENDED: S++, // <!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++ // <script> ... <\n  }\n\n  sax.XML_ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\"\n  }\n\n  sax.ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\",\n    'AElig': 198,\n    'Aacute': 193,\n    'Acirc': 194,\n    'Agrave': 192,\n    'Aring': 197,\n    'Atilde': 195,\n    'Auml': 196,\n    'Ccedil': 199,\n    'ETH': 208,\n    'Eacute': 201,\n    'Ecirc': 202,\n    'Egrave': 200,\n    'Euml': 203,\n    'Iacute': 205,\n    'Icirc': 206,\n    'Igrave': 204,\n    'Iuml': 207,\n    'Ntilde': 209,\n    'Oacute': 211,\n    'Ocirc': 212,\n    'Ograve': 210,\n    'Oslash': 216,\n    'Otilde': 213,\n    'Ouml': 214,\n    'THORN': 222,\n    'Uacute': 218,\n    'Ucirc': 219,\n    'Ugrave': 217,\n    'Uuml': 220,\n    'Yacute': 221,\n    'aacute': 225,\n    'acirc': 226,\n    'aelig': 230,\n    'agrave': 224,\n    'aring': 229,\n    'atilde': 227,\n    'auml': 228,\n    'ccedil': 231,\n    'eacute': 233,\n    'ecirc': 234,\n    'egrave': 232,\n    'eth': 240,\n    'euml': 235,\n    'iacute': 237,\n    'icirc': 238,\n    'igrave': 236,\n    'iuml': 239,\n    'ntilde': 241,\n    'oacute': 243,\n    'ocirc': 244,\n    'ograve': 242,\n    'oslash': 248,\n    'otilde': 245,\n    'ouml': 246,\n    'szlig': 223,\n    'thorn': 254,\n    'uacute': 250,\n    'ucirc': 251,\n    'ugrave': 249,\n    'uuml': 252,\n    'yacute': 253,\n    'yuml': 255,\n    'copy': 169,\n    'reg': 174,\n    'nbsp': 160,\n    'iexcl': 161,\n    'cent': 162,\n    'pound': 163,\n    'curren': 164,\n    'yen': 165,\n    'brvbar': 166,\n    'sect': 167,\n    'uml': 168,\n    'ordf': 170,\n    'laquo': 171,\n    'not': 172,\n    'shy': 173,\n    'macr': 175,\n    'deg': 176,\n    'plusmn': 177,\n    'sup1': 185,\n    'sup2': 178,\n    'sup3': 179,\n    'acute': 180,\n    'micro': 181,\n    'para': 182,\n    'middot': 183,\n    'cedil': 184,\n    'ordm': 186,\n    'raquo': 187,\n    'frac14': 188,\n    'frac12': 189,\n    'frac34': 190,\n    'iquest': 191,\n    'times': 215,\n    'divide': 247,\n    'OElig': 338,\n    'oelig': 339,\n    'Scaron': 352,\n    'scaron': 353,\n    'Yuml': 376,\n    'fnof': 402,\n    'circ': 710,\n    'tilde': 732,\n    'Alpha': 913,\n    'Beta': 914,\n    'Gamma': 915,\n    'Delta': 916,\n    'Epsilon': 917,\n    'Zeta': 918,\n    'Eta': 919,\n    'Theta': 920,\n    'Iota': 921,\n    'Kappa': 922,\n    'Lambda': 923,\n    'Mu': 924,\n    'Nu': 925,\n    'Xi': 926,\n    'Omicron': 927,\n    'Pi': 928,\n    'Rho': 929,\n    'Sigma': 931,\n    'Tau': 932,\n    'Upsilon': 933,\n    'Phi': 934,\n    'Chi': 935,\n    'Psi': 936,\n    'Omega': 937,\n    'alpha': 945,\n    'beta': 946,\n    'gamma': 947,\n    'delta': 948,\n    'epsilon': 949,\n    'zeta': 950,\n    'eta': 951,\n    'theta': 952,\n    'iota': 953,\n    'kappa': 954,\n    'lambda': 955,\n    'mu': 956,\n    'nu': 957,\n    'xi': 958,\n    'omicron': 959,\n    'pi': 960,\n    'rho': 961,\n    'sigmaf': 962,\n    'sigma': 963,\n    'tau': 964,\n    'upsilon': 965,\n    'phi': 966,\n    'chi': 967,\n    'psi': 968,\n    'omega': 969,\n    'thetasym': 977,\n    'upsih': 978,\n    'piv': 982,\n    'ensp': 8194,\n    'emsp': 8195,\n    'thinsp': 8201,\n    'zwnj': 8204,\n    'zwj': 8205,\n    'lrm': 8206,\n    'rlm': 8207,\n    'ndash': 8211,\n    'mdash': 8212,\n    'lsquo': 8216,\n    'rsquo': 8217,\n    'sbquo': 8218,\n    'ldquo': 8220,\n    'rdquo': 8221,\n    'bdquo': 8222,\n    'dagger': 8224,\n    'Dagger': 8225,\n    'bull': 8226,\n    'hellip': 8230,\n    'permil': 8240,\n    'prime': 8242,\n    'Prime': 8243,\n    'lsaquo': 8249,\n    'rsaquo': 8250,\n    'oline': 8254,\n    'frasl': 8260,\n    'euro': 8364,\n    'image': 8465,\n    'weierp': 8472,\n    'real': 8476,\n    'trade': 8482,\n    'alefsym': 8501,\n    'larr': 8592,\n    'uarr': 8593,\n    'rarr': 8594,\n    'darr': 8595,\n    'harr': 8596,\n    'crarr': 8629,\n    'lArr': 8656,\n    'uArr': 8657,\n    'rArr': 8658,\n    'dArr': 8659,\n    'hArr': 8660,\n    'forall': 8704,\n    'part': 8706,\n    'exist': 8707,\n    'empty': 8709,\n    'nabla': 8711,\n    'isin': 8712,\n    'notin': 8713,\n    'ni': 8715,\n    'prod': 8719,\n    'sum': 8721,\n    'minus': 8722,\n    'lowast': 8727,\n    'radic': 8730,\n    'prop': 8733,\n    'infin': 8734,\n    'ang': 8736,\n    'and': 8743,\n    'or': 8744,\n    'cap': 8745,\n    'cup': 8746,\n    'int': 8747,\n    'there4': 8756,\n    'sim': 8764,\n    'cong': 8773,\n    'asymp': 8776,\n    'ne': 8800,\n    'equiv': 8801,\n    'le': 8804,\n    'ge': 8805,\n    'sub': 8834,\n    'sup': 8835,\n    'nsub': 8836,\n    'sube': 8838,\n    'supe': 8839,\n    'oplus': 8853,\n    'otimes': 8855,\n    'perp': 8869,\n    'sdot': 8901,\n    'lceil': 8968,\n    'rceil': 8969,\n    'lfloor': 8970,\n    'rfloor': 8971,\n    'lang': 9001,\n    'rang': 9002,\n    'loz': 9674,\n    'spades': 9824,\n    'clubs': 9827,\n    'hearts': 9829,\n    'diams': 9830\n  }\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n  })\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s\n  }\n\n  // shorthand\n  S = sax.STATE\n\n  function emit (parser, event, data) {\n    parser[event] && parser[event](data)\n  }\n\n  function emitNode (parser, nodeType, data) {\n    if (parser.textNode) closeText(parser)\n    emit(parser, nodeType, data)\n  }\n\n  function closeText (parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode)\n    if (parser.textNode) emit(parser, 'ontext', parser.textNode)\n    parser.textNode = ''\n  }\n\n  function textopts (opt, text) {\n    if (opt.trim) text = text.trim()\n    if (opt.normalize) text = text.replace(/\\s+/g, ' ')\n    return text\n  }\n\n  function error (parser, er) {\n    closeText(parser)\n    if (parser.trackPosition) {\n      er += '\\nLine: ' + parser.line +\n        '\\nColumn: ' + parser.column +\n        '\\nChar: ' + parser.c\n    }\n    er = new Error(er)\n    parser.error = er\n    emit(parser, 'onerror', er)\n    return parser\n  }\n\n  function end (parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')\n    if ((parser.state !== S.BEGIN) &&\n      (parser.state !== S.BEGIN_WHITESPACE) &&\n      (parser.state !== S.TEXT)) {\n      error(parser, 'Unexpected end')\n    }\n    closeText(parser)\n    parser.c = ''\n    parser.closed = true\n    emit(parser, 'onend')\n    SAXParser.call(parser, parser.strict, parser.opt)\n    return parser\n  }\n\n  function strictFail (parser, message) {\n    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {\n      throw new Error('bad call to strictFail')\n    }\n    if (parser.strict) {\n      error(parser, message)\n    }\n  }\n\n  function newTag (parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    var tag = parser.tag = { name: parser.tagName, attributes: {} }\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns\n    }\n    parser.attribList.length = 0\n    emitNode(parser, 'onopentagstart', tag)\n  }\n\n  function qname (name, attribute) {\n    var i = name.indexOf(':')\n    var qualName = i < 0 ? [ '', name ] : name.split(':')\n    var prefix = qualName[0]\n    var local = qualName[1]\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === 'xmlns') {\n      prefix = 'xmlns'\n      local = ''\n    }\n\n    return { prefix: prefix, local: local }\n  }\n\n  function attrib (parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]()\n    }\n\n    if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n      parser.attribName = parser.attribValue = ''\n      return\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true)\n      var prefix = qn.prefix\n      var local = qn.local\n\n      if (prefix === 'xmlns') {\n        // namespace binding attribute. push the binding into scope\n        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser,\n            'xml: prefix must be bound to ' + XML_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser,\n            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else {\n          var tag = parser.tag\n          var parent = parser.tags[parser.tags.length - 1] || parser\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns)\n          }\n          tag.ns[local] = parser.attribValue\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue])\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue\n      emitNode(parser, 'onattribute', {\n        name: parser.attribName,\n        value: parser.attribValue\n      })\n    }\n\n    parser.attribName = parser.attribValue = ''\n  }\n\n  function openTag (parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName)\n      tag.prefix = qn.prefix\n      tag.local = qn.local\n      tag.uri = tag.ns[qn.prefix] || ''\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, 'Unbound namespace prefix: ' +\n          JSON.stringify(parser.tagName))\n        tag.uri = qn.prefix\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, 'onopennamespace', {\n            prefix: p,\n            uri: tag.ns[p]\n          })\n        })\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i]\n        var name = nv[0]\n        var value = nv[1]\n        var qualName = qname(name, true)\n        var prefix = qualName.prefix\n        var local = qualName.local\n        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        }\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== 'xmlns' && !uri) {\n          strictFail(parser, 'Unbound namespace prefix: ' +\n            JSON.stringify(prefix))\n          a.uri = prefix\n        }\n        parser.tag.attributes[name] = a\n        emitNode(parser, 'onattribute', a)\n      }\n      parser.attribList.length = 0\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing\n\n    // process the tag\n    parser.sawRoot = true\n    parser.tags.push(parser.tag)\n    emitNode(parser, 'onopentag', parser.tag)\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n        parser.state = S.SCRIPT\n      } else {\n        parser.state = S.TEXT\n      }\n      parser.tag = null\n      parser.tagName = ''\n    }\n    parser.attribName = parser.attribValue = ''\n    parser.attribList.length = 0\n  }\n\n  function closeTag (parser) {\n    if (!parser.tagName) {\n      strictFail(parser, 'Weird empty close tag.')\n      parser.textNode += '</>'\n      parser.state = S.TEXT\n      return\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== 'script') {\n        parser.script += '</' + parser.tagName + '>'\n        parser.tagName = ''\n        parser.state = S.SCRIPT\n        return\n      }\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length\n    var tagName = parser.tagName\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]()\n    }\n    var closeTo = tagName\n    while (t--) {\n      var close = parser.tags[t]\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, 'Unexpected close tag')\n      } else {\n        break\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)\n      parser.textNode += '</' + parser.tagName + '>'\n      parser.state = S.TEXT\n      return\n    }\n    parser.tagName = tagName\n    var s = parser.tags.length\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop()\n      parser.tagName = parser.tag.name\n      emitNode(parser, 'onclosetag', parser.tagName)\n\n      var x = {}\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i]\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p]\n          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })\n        })\n      }\n    }\n    if (t === 0) parser.closedRoot = true\n    parser.tagName = parser.attribValue = parser.attribName = ''\n    parser.attribList.length = 0\n    parser.state = S.TEXT\n  }\n\n  function parseEntity (parser) {\n    var entity = parser.entity\n    var entityLC = entity.toLowerCase()\n    var num\n    var numStr = ''\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity]\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC]\n    }\n    entity = entityLC\n    if (entity.charAt(0) === '#') {\n      if (entity.charAt(1) === 'x') {\n        entity = entity.slice(2)\n        num = parseInt(entity, 16)\n        numStr = num.toString(16)\n      } else {\n        entity = entity.slice(1)\n        num = parseInt(entity, 10)\n        numStr = num.toString(10)\n      }\n    }\n    entity = entity.replace(/^0+/, '')\n    if (isNaN(num) || numStr.toLowerCase() !== entity) {\n      strictFail(parser, 'Invalid character entity')\n      return '&' + parser.entity + ';'\n    }\n\n    return String.fromCodePoint(num)\n  }\n\n  function beginWhiteSpace (parser, c) {\n    if (c === '<') {\n      parser.state = S.OPEN_WAKA\n      parser.startTagPosition = parser.position\n    } else if (!isWhitespace(c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, 'Non-whitespace before first tag.')\n      parser.textNode = c\n      parser.state = S.TEXT\n    }\n  }\n\n  function charAt (chunk, i) {\n    var result = ''\n    if (i < chunk.length) {\n      result = chunk.charAt(i)\n    }\n    return result\n  }\n\n  function write (chunk) {\n    var parser = this\n    if (this.error) {\n      throw this.error\n    }\n    if (parser.closed) {\n      return error(parser,\n        'Cannot write after close. Assign an onready handler.')\n    }\n    if (chunk === null) {\n      return end(parser)\n    }\n    if (typeof chunk === 'object') {\n      chunk = chunk.toString()\n    }\n    var i = 0\n    var c = ''\n    while (true) {\n      c = charAt(chunk, i++)\n      parser.c = c\n\n      if (!c) {\n        break\n      }\n\n      if (parser.trackPosition) {\n        parser.position++\n        if (c === '\\n') {\n          parser.line++\n          parser.column = 0\n        } else {\n          parser.column++\n        }\n      }\n\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE\n          if (c === '\\uFEFF') {\n            continue\n          }\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1\n            while (c && c !== '<' && c !== '&') {\n              c = charAt(chunk, i++)\n              if (c && parser.trackPosition) {\n                parser.position++\n                if (c === '\\n') {\n                  parser.line++\n                  parser.column = 0\n                } else {\n                  parser.column++\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1)\n          }\n          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n            parser.state = S.OPEN_WAKA\n            parser.startTagPosition = parser.position\n          } else {\n            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, 'Text data outside of root node.')\n            }\n            if (c === '&') {\n              parser.state = S.TEXT_ENTITY\n            } else {\n              parser.textNode += c\n            }\n          }\n          continue\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === '<') {\n            parser.state = S.SCRIPT_ENDING\n          } else {\n            parser.script += c\n          }\n          continue\n\n        case S.SCRIPT_ENDING:\n          if (c === '/') {\n            parser.state = S.CLOSE_TAG\n          } else {\n            parser.script += '<' + c\n            parser.state = S.SCRIPT\n          }\n          continue\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === '!') {\n            parser.state = S.SGML_DECL\n            parser.sgmlDecl = ''\n          } else if (isWhitespace(c)) {\n            // wait for it...\n          } else if (isMatch(nameStart, c)) {\n            parser.state = S.OPEN_TAG\n            parser.tagName = c\n          } else if (c === '/') {\n            parser.state = S.CLOSE_TAG\n            parser.tagName = ''\n          } else if (c === '?') {\n            parser.state = S.PROC_INST\n            parser.procInstName = parser.procInstBody = ''\n          } else {\n            strictFail(parser, 'Unencoded <')\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition\n              c = new Array(pad).join(' ') + c\n            }\n            parser.textNode += '<' + c\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, 'onopencdata')\n            parser.state = S.CDATA\n            parser.sgmlDecl = ''\n            parser.cdata = ''\n          } else if (parser.sgmlDecl + c === '--') {\n            parser.state = S.COMMENT\n            parser.comment = ''\n            parser.sgmlDecl = ''\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser,\n                'Inappropriately located doctype declaration')\n            }\n            parser.doctype = ''\n            parser.sgmlDecl = ''\n          } else if (c === '>') {\n            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)\n            parser.sgmlDecl = ''\n            parser.state = S.TEXT\n          } else if (isQuote(c)) {\n            parser.state = S.SGML_DECL_QUOTED\n            parser.sgmlDecl += c\n          } else {\n            parser.sgmlDecl += c\n          }\n          continue\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL\n            parser.q = ''\n          }\n          parser.sgmlDecl += c\n          continue\n\n        case S.DOCTYPE:\n          if (c === '>') {\n            parser.state = S.TEXT\n            emitNode(parser, 'ondoctype', parser.doctype)\n            parser.doctype = true // just remember that we saw it.\n          } else {\n            parser.doctype += c\n            if (c === '[') {\n              parser.state = S.DOCTYPE_DTD\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_QUOTED\n              parser.q = c\n            }\n          }\n          continue\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.q = ''\n            parser.state = S.DOCTYPE\n          }\n          continue\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c\n          if (c === ']') {\n            parser.state = S.DOCTYPE\n          } else if (isQuote(c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED\n            parser.q = c\n          }\n          continue\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD\n            parser.q = ''\n          }\n          continue\n\n        case S.COMMENT:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDING\n          } else {\n            parser.comment += c\n          }\n          continue\n\n        case S.COMMENT_ENDING:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDED\n            parser.comment = textopts(parser.opt, parser.comment)\n            if (parser.comment) {\n              emitNode(parser, 'oncomment', parser.comment)\n            }\n            parser.comment = ''\n          } else {\n            parser.comment += '-' + c\n            parser.state = S.COMMENT\n          }\n          continue\n\n        case S.COMMENT_ENDED:\n          if (c !== '>') {\n            strictFail(parser, 'Malformed comment')\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += '--' + c\n            parser.state = S.COMMENT\n          } else {\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.CDATA:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING\n          } else {\n            parser.cdata += c\n          }\n          continue\n\n        case S.CDATA_ENDING:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING_2\n          } else {\n            parser.cdata += ']' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.CDATA_ENDING_2:\n          if (c === '>') {\n            if (parser.cdata) {\n              emitNode(parser, 'oncdata', parser.cdata)\n            }\n            emitNode(parser, 'onclosecdata')\n            parser.cdata = ''\n            parser.state = S.TEXT\n          } else if (c === ']') {\n            parser.cdata += ']'\n          } else {\n            parser.cdata += ']]' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.PROC_INST:\n          if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else if (isWhitespace(c)) {\n            parser.state = S.PROC_INST_BODY\n          } else {\n            parser.procInstName += c\n          }\n          continue\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && isWhitespace(c)) {\n            continue\n          } else if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else {\n            parser.procInstBody += c\n          }\n          continue\n\n        case S.PROC_INST_ENDING:\n          if (c === '>') {\n            emitNode(parser, 'onprocessinginstruction', {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            })\n            parser.procInstName = parser.procInstBody = ''\n            parser.state = S.TEXT\n          } else {\n            parser.procInstBody += '?' + c\n            parser.state = S.PROC_INST_BODY\n          }\n          continue\n\n        case S.OPEN_TAG:\n          if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else {\n            newTag(parser)\n            if (c === '>') {\n              openTag(parser)\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, 'Invalid character in tag name')\n              }\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.OPEN_TAG_SLASH:\n          if (c === '>') {\n            openTag(parser, true)\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Forward-slash in opening tag not followed by >')\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (isWhitespace(c)) {\n            continue\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (c === '>') {\n            strictFail(parser, 'Attribute without value')\n            parser.attribValue = parser.attribName\n            attrib(parser)\n            openTag(parser)\n          } else if (isWhitespace(c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE\n          } else if (isMatch(nameBody, c)) {\n            parser.attribName += c\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (isWhitespace(c)) {\n            continue\n          } else {\n            strictFail(parser, 'Attribute without value')\n            parser.tag.attributes[parser.attribName] = ''\n            parser.attribValue = ''\n            emitNode(parser, 'onattribute', {\n              name: parser.attribName,\n              value: ''\n            })\n            parser.attribName = ''\n            if (c === '>') {\n              openTag(parser)\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c\n              parser.state = S.ATTRIB_NAME\n            } else {\n              strictFail(parser, 'Invalid attribute name')\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.ATTRIB_VALUE:\n          if (isWhitespace(c)) {\n            continue\n          } else if (isQuote(c)) {\n            parser.q = c\n            parser.state = S.ATTRIB_VALUE_QUOTED\n          } else {\n            strictFail(parser, 'Unquoted attribute value')\n            parser.state = S.ATTRIB_VALUE_UNQUOTED\n            parser.attribValue = c\n          }\n          continue\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          parser.q = ''\n          parser.state = S.ATTRIB_VALUE_CLOSED\n          continue\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (isWhitespace(c)) {\n            parser.state = S.ATTRIB\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            strictFail(parser, 'No whitespace between attributes')\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (!isAttribEnd(c)) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          if (c === '>') {\n            openTag(parser)\n          } else {\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (isWhitespace(c)) {\n              continue\n            } else if (notMatch(nameStart, c)) {\n              if (parser.script) {\n                parser.script += '</' + c\n                parser.state = S.SCRIPT\n              } else {\n                strictFail(parser, 'Invalid tagname in closing tag.')\n              }\n            } else {\n              parser.tagName = c\n            }\n          } else if (c === '>') {\n            closeTag(parser)\n          } else if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else if (parser.script) {\n            parser.script += '</' + parser.tagName\n            parser.tagName = ''\n            parser.state = S.SCRIPT\n          } else {\n            if (!isWhitespace(c)) {\n              strictFail(parser, 'Invalid tagname in closing tag')\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE\n          }\n          continue\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (isWhitespace(c)) {\n            continue\n          }\n          if (c === '>') {\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Invalid characters in closing tag')\n          }\n          continue\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState\n          var buffer\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT\n              buffer = 'textNode'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED\n              buffer = 'attribValue'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED\n              buffer = 'attribValue'\n              break\n          }\n\n          if (c === ';') {\n            parser[buffer] += parseEntity(parser)\n            parser.entity = ''\n            parser.state = returnState\n          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n            parser.entity += c\n          } else {\n            strictFail(parser, 'Invalid character in entity name')\n            parser[buffer] += '&' + parser.entity + c\n            parser.entity = ''\n            parser.state = returnState\n          }\n\n          continue\n\n        default:\n          throw new Error(parser, 'Unknown state: ' + parser.state)\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser)\n    }\n    return parser\n  }\n\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  /* istanbul ignore next */\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode\n      var floor = Math.floor\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000\n        var codeUnits = []\n        var highSurrogate\n        var lowSurrogate\n        var index = -1\n        var length = arguments.length\n        if (!length) {\n          return ''\n        }\n        var result = ''\n        while (++index < length) {\n          var codePoint = Number(arguments[index])\n          if (\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10FFFF || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError('Invalid code point: ' + codePoint)\n          }\n          if (codePoint <= 0xFFFF) { // BMP code point\n            codeUnits.push(codePoint)\n          } else { // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000\n            highSurrogate = (codePoint >> 10) + 0xD800\n            lowSurrogate = (codePoint % 0x400) + 0xDC00\n            codeUnits.push(highSurrogate, lowSurrogate)\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits)\n            codeUnits.length = 0\n          }\n        }\n        return result\n      }\n      /* istanbul ignore next */\n      if (Object.defineProperty) {\n        Object.defineProperty(String, 'fromCodePoint', {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true\n        })\n      } else {\n        String.fromCodePoint = fromCodePoint\n      }\n    }())\n  }\n})(typeof exports === 'undefined' ? this.sax = {} : exports)\n","module.exports = {\r\n\r\n  isArray: function(value) {\r\n    if (Array.isArray) {\r\n      return Array.isArray(value);\r\n    }\r\n    // fallback for older browsers like  IE 8\r\n    return Object.prototype.toString.call( value ) === '[object Array]';\r\n  }\r\n\r\n};\r\n","var isArray = require('./array-helper').isArray;\r\n\r\nmodule.exports = {\r\n\r\n  copyOptions: function (options) {\r\n    var key, copy = {};\r\n    for (key in options) {\r\n      if (options.hasOwnProperty(key)) {\r\n        copy[key] = options[key];\r\n      }\r\n    }\r\n    return copy;\r\n  },\r\n\r\n  ensureFlagExists: function (item, options) {\r\n    if (!(item in options) || typeof options[item] !== 'boolean') {\r\n      options[item] = false;\r\n    }\r\n  },\r\n\r\n  ensureSpacesExists: function (options) {\r\n    if (!('spaces' in options) || (typeof options.spaces !== 'number' && typeof options.spaces !== 'string')) {\r\n      options.spaces = 0;\r\n    }\r\n  },\r\n\r\n  ensureAlwaysArrayExists: function (options) {\r\n    if (!('alwaysArray' in options) || (typeof options.alwaysArray !== 'boolean' && !isArray(options.alwaysArray))) {\r\n      options.alwaysArray = false;\r\n    }\r\n  },\r\n\r\n  ensureKeyExists: function (key, options) {\r\n    if (!(key + 'Key' in options) || typeof options[key + 'Key'] !== 'string') {\r\n      options[key + 'Key'] = options.compact ? '_' + key : key;\r\n    }\r\n  },\r\n\r\n  checkFnExists: function (key, options) {\r\n    return key + 'Fn' in options;\r\n  }\r\n\r\n};\r\n","var sax = require('sax');\r\nvar expat /*= require('node-expat');*/ = { on: function () { }, parse: function () { } };\r\nvar helper = require('./options-helper');\r\nvar isArray = require('./array-helper').isArray;\r\n\r\nvar options;\r\nvar pureJsParser = true;\r\nvar currentElement;\r\n\r\nfunction validateOptions(userOptions) {\r\n  options = helper.copyOptions(userOptions);\r\n  helper.ensureFlagExists('ignoreDeclaration', options);\r\n  helper.ensureFlagExists('ignoreInstruction', options);\r\n  helper.ensureFlagExists('ignoreAttributes', options);\r\n  helper.ensureFlagExists('ignoreText', options);\r\n  helper.ensureFlagExists('ignoreComment', options);\r\n  helper.ensureFlagExists('ignoreCdata', options);\r\n  helper.ensureFlagExists('ignoreDoctype', options);\r\n  helper.ensureFlagExists('compact', options);\r\n  helper.ensureFlagExists('alwaysChildren', options);\r\n  helper.ensureFlagExists('addParent', options);\r\n  helper.ensureFlagExists('trim', options);\r\n  helper.ensureFlagExists('nativeType', options);\r\n  helper.ensureFlagExists('nativeTypeAttributes', options);\r\n  helper.ensureFlagExists('sanitize', options);\r\n  helper.ensureFlagExists('instructionHasAttributes', options);\r\n  helper.ensureFlagExists('captureSpacesBetweenElements', options);\r\n  helper.ensureAlwaysArrayExists(options);\r\n  helper.ensureKeyExists('declaration', options);\r\n  helper.ensureKeyExists('instruction', options);\r\n  helper.ensureKeyExists('attributes', options);\r\n  helper.ensureKeyExists('text', options);\r\n  helper.ensureKeyExists('comment', options);\r\n  helper.ensureKeyExists('cdata', options);\r\n  helper.ensureKeyExists('doctype', options);\r\n  helper.ensureKeyExists('type', options);\r\n  helper.ensureKeyExists('name', options);\r\n  helper.ensureKeyExists('elements', options);\r\n  helper.ensureKeyExists('parent', options);\r\n  helper.checkFnExists('doctype', options);\r\n  helper.checkFnExists('instruction', options);\r\n  helper.checkFnExists('cdata', options);\r\n  helper.checkFnExists('comment', options);\r\n  helper.checkFnExists('text', options);\r\n  helper.checkFnExists('instructionName', options);\r\n  helper.checkFnExists('elementName', options);\r\n  helper.checkFnExists('attributeName', options);\r\n  helper.checkFnExists('attributeValue', options);\r\n  helper.checkFnExists('attributes', options);\r\n  return options;\r\n}\r\n\r\nfunction nativeType(value) {\r\n  var nValue = Number(value);\r\n  if (!isNaN(nValue)) {\r\n    return nValue;\r\n  }\r\n  var bValue = value.toLowerCase();\r\n  if (bValue === 'true') {\r\n    return true;\r\n  } else if (bValue === 'false') {\r\n    return false;\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction addField(type, value) {\r\n  var key;\r\n  if (options.compact) {\r\n    if (\r\n      !currentElement[options[type + 'Key']] &&\r\n      (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + 'Key']) !== -1 : options.alwaysArray)\r\n    ) {\r\n      currentElement[options[type + 'Key']] = [];\r\n    }\r\n    if (currentElement[options[type + 'Key']] && !isArray(currentElement[options[type + 'Key']])) {\r\n      currentElement[options[type + 'Key']] = [currentElement[options[type + 'Key']]];\r\n    }\r\n    if (type + 'Fn' in options && typeof value === 'string') {\r\n      value = options[type + 'Fn'](value, currentElement);\r\n    }\r\n    if (type === 'instruction' && ('instructionFn' in options || 'instructionNameFn' in options)) {\r\n      for (key in value) {\r\n        if (value.hasOwnProperty(key)) {\r\n          if ('instructionFn' in options) {\r\n            value[key] = options.instructionFn(value[key], key, currentElement);\r\n          } else {\r\n            var temp = value[key];\r\n            delete value[key];\r\n            value[options.instructionNameFn(key, temp, currentElement)] = temp;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (isArray(currentElement[options[type + 'Key']])) {\r\n      currentElement[options[type + 'Key']].push(value);\r\n    } else {\r\n      currentElement[options[type + 'Key']] = value;\r\n    }\r\n  } else {\r\n    if (!currentElement[options.elementsKey]) {\r\n      currentElement[options.elementsKey] = [];\r\n    }\r\n    var element = {};\r\n    element[options.typeKey] = type;\r\n    if (type === 'instruction') {\r\n      for (key in value) {\r\n        if (value.hasOwnProperty(key)) {\r\n          break;\r\n        }\r\n      }\r\n      element[options.nameKey] = 'instructionNameFn' in options ? options.instructionNameFn(key, value, currentElement) : key;\r\n      if (options.instructionHasAttributes) {\r\n        element[options.attributesKey] = value[key][options.attributesKey];\r\n        if ('instructionFn' in options) {\r\n          element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);\r\n        }\r\n      } else {\r\n        if ('instructionFn' in options) {\r\n          value[key] = options.instructionFn(value[key], key, currentElement);\r\n        }\r\n        element[options.instructionKey] = value[key];\r\n      }\r\n    } else {\r\n      if (type + 'Fn' in options) {\r\n        value = options[type + 'Fn'](value, currentElement);\r\n      }\r\n      element[options[type + 'Key']] = value;\r\n    }\r\n    if (options.addParent) {\r\n      element[options.parentKey] = currentElement;\r\n    }\r\n    currentElement[options.elementsKey].push(element);\r\n  }\r\n}\r\n\r\nfunction manipulateAttributes(attributes) {\r\n  if ('attributesFn' in options && attributes) {\r\n    attributes = options.attributesFn(attributes, currentElement);\r\n  }\r\n  if ((options.trim || 'attributeValueFn' in options || 'attributeNameFn' in options || options.nativeTypeAttributes) && attributes) {\r\n    var key;\r\n    for (key in attributes) {\r\n      if (attributes.hasOwnProperty(key)) {\r\n        if (options.trim) attributes[key] = attributes[key].trim();\r\n        if (options.nativeTypeAttributes) {\r\n          attributes[key] = nativeType(attributes[key]);\r\n        }\r\n        if ('attributeValueFn' in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);\r\n        if ('attributeNameFn' in options) {\r\n          var temp = attributes[key];\r\n          delete attributes[key];\r\n          attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return attributes;\r\n}\r\n\r\nfunction onInstruction(instruction) {\r\n  var attributes = {};\r\n  if (instruction.body && (instruction.name.toLowerCase() === 'xml' || options.instructionHasAttributes)) {\r\n    var attrsRegExp = /([\\w:-]+)\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\w+))\\s*/g;\r\n    var match;\r\n    while ((match = attrsRegExp.exec(instruction.body)) !== null) {\r\n      attributes[match[1]] = match[2] || match[3] || match[4];\r\n    }\r\n    attributes = manipulateAttributes(attributes);\r\n  }\r\n  if (instruction.name.toLowerCase() === 'xml') {\r\n    if (options.ignoreDeclaration) {\r\n      return;\r\n    }\r\n    currentElement[options.declarationKey] = {};\r\n    if (Object.keys(attributes).length) {\r\n      currentElement[options.declarationKey][options.attributesKey] = attributes;\r\n    }\r\n    if (options.addParent) {\r\n      currentElement[options.declarationKey][options.parentKey] = currentElement;\r\n    }\r\n  } else {\r\n    if (options.ignoreInstruction) {\r\n      return;\r\n    }\r\n    if (options.trim) {\r\n      instruction.body = instruction.body.trim();\r\n    }\r\n    var value = {};\r\n    if (options.instructionHasAttributes && Object.keys(attributes).length) {\r\n      value[instruction.name] = {};\r\n      value[instruction.name][options.attributesKey] = attributes;\r\n    } else {\r\n      value[instruction.name] = instruction.body;\r\n    }\r\n    addField('instruction', value);\r\n  }\r\n}\r\n\r\nfunction onStartElement(name, attributes) {\r\n  var element;\r\n  if (typeof name === 'object') {\r\n    attributes = name.attributes;\r\n    name = name.name;\r\n  }\r\n  attributes = manipulateAttributes(attributes);\r\n  if ('elementNameFn' in options) {\r\n    name = options.elementNameFn(name, currentElement);\r\n  }\r\n  if (options.compact) {\r\n    element = {};\r\n    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {\r\n      element[options.attributesKey] = {};\r\n      var key;\r\n      for (key in attributes) {\r\n        if (attributes.hasOwnProperty(key)) {\r\n          element[options.attributesKey][key] = attributes[key];\r\n        }\r\n      }\r\n    }\r\n    if (\r\n      !(name in currentElement) &&\r\n      (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)\r\n    ) {\r\n      currentElement[name] = [];\r\n    }\r\n    if (currentElement[name] && !isArray(currentElement[name])) {\r\n      currentElement[name] = [currentElement[name]];\r\n    }\r\n    if (isArray(currentElement[name])) {\r\n      currentElement[name].push(element);\r\n    } else {\r\n      currentElement[name] = element;\r\n    }\r\n  } else {\r\n    if (!currentElement[options.elementsKey]) {\r\n      currentElement[options.elementsKey] = [];\r\n    }\r\n    element = {};\r\n    element[options.typeKey] = 'element';\r\n    element[options.nameKey] = name;\r\n    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {\r\n      element[options.attributesKey] = attributes;\r\n    }\r\n    if (options.alwaysChildren) {\r\n      element[options.elementsKey] = [];\r\n    }\r\n    currentElement[options.elementsKey].push(element);\r\n  }\r\n  element[options.parentKey] = currentElement; // will be deleted in onEndElement() if !options.addParent\r\n  currentElement = element;\r\n}\r\n\r\nfunction onText(text) {\r\n  if (options.ignoreText) {\r\n    return;\r\n  }\r\n  if (!text.trim() && !options.captureSpacesBetweenElements) {\r\n    return;\r\n  }\r\n  if (options.trim) {\r\n    text = text.trim();\r\n  }\r\n  if (options.nativeType) {\r\n    text = nativeType(text);\r\n  }\r\n  if (options.sanitize) {\r\n    text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\r\n  }\r\n  addField('text', text);\r\n}\r\n\r\nfunction onComment(comment) {\r\n  if (options.ignoreComment) {\r\n    return;\r\n  }\r\n  if (options.trim) {\r\n    comment = comment.trim();\r\n  }\r\n  addField('comment', comment);\r\n}\r\n\r\nfunction onEndElement(name) {\r\n  var parentElement = currentElement[options.parentKey];\r\n  if (!options.addParent) {\r\n    delete currentElement[options.parentKey];\r\n  }\r\n  currentElement = parentElement;\r\n}\r\n\r\nfunction onCdata(cdata) {\r\n  if (options.ignoreCdata) {\r\n    return;\r\n  }\r\n  if (options.trim) {\r\n    cdata = cdata.trim();\r\n  }\r\n  addField('cdata', cdata);\r\n}\r\n\r\nfunction onDoctype(doctype) {\r\n  if (options.ignoreDoctype) {\r\n    return;\r\n  }\r\n  doctype = doctype.replace(/^ /, '');\r\n  if (options.trim) {\r\n    doctype = doctype.trim();\r\n  }\r\n  addField('doctype', doctype);\r\n}\r\n\r\nfunction onError(error) {\r\n  error.note = error; //console.error(error);\r\n}\r\n\r\nmodule.exports = function (xml, userOptions) {\r\n\r\n  var parser = pureJsParser ? sax.parser(true, {}) : parser = new expat.Parser('UTF-8');\r\n  var result = {};\r\n  currentElement = result;\r\n\r\n  options = validateOptions(userOptions);\r\n\r\n  if (pureJsParser) {\r\n    parser.opt = {strictEntities: true};\r\n    parser.onopentag = onStartElement;\r\n    parser.ontext = onText;\r\n    parser.oncomment = onComment;\r\n    parser.onclosetag = onEndElement;\r\n    parser.onerror = onError;\r\n    parser.oncdata = onCdata;\r\n    parser.ondoctype = onDoctype;\r\n    parser.onprocessinginstruction = onInstruction;\r\n  } else {\r\n    parser.on('startElement', onStartElement);\r\n    parser.on('text', onText);\r\n    parser.on('comment', onComment);\r\n    parser.on('endElement', onEndElement);\r\n    parser.on('error', onError);\r\n    //parser.on('startCdata', onStartCdata);\r\n    //parser.on('endCdata', onEndCdata);\r\n    //parser.on('entityDecl', onEntityDecl);\r\n  }\r\n\r\n  if (pureJsParser) {\r\n    parser.write(xml).close();\r\n  } else {\r\n    if (!parser.parse(xml)) {\r\n      throw new Error('XML parsing error: ' + parser.getError());\r\n    }\r\n  }\r\n\r\n  if (result[options.elementsKey]) {\r\n    var temp = result[options.elementsKey];\r\n    delete result[options.elementsKey];\r\n    result[options.elementsKey] = temp;\r\n    delete result.text;\r\n  }\r\n\r\n  return result;\r\n\r\n};\r\n","var helper = require('./options-helper');\r\nvar xml2js = require('./xml2js');\r\n\r\nfunction validateOptions (userOptions) {\r\n  var options = helper.copyOptions(userOptions);\r\n  helper.ensureSpacesExists(options);\r\n  return options;\r\n}\r\n\r\nmodule.exports = function(xml, userOptions) {\r\n  var options, js, json, parentKey;\r\n  options = validateOptions(userOptions);\r\n  js = xml2js(xml, options);\r\n  parentKey = 'compact' in options && options.compact ? '_parent' : 'parent';\r\n  // parentKey = ptions.compact ? '_parent' : 'parent'; // consider this\r\n  if ('addParent' in options && options.addParent) {\r\n    json = JSON.stringify(js, function (k, v) { return k === parentKey? '_' : v; }, options.spaces);\r\n  } else {\r\n    json = JSON.stringify(js, null, options.spaces);\r\n  }\r\n  return json.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\r\n};\r\n","var helper = require('./options-helper');\nvar isArray = require('./array-helper').isArray;\n\nvar currentElement, currentElementName;\n\nfunction validateOptions(userOptions) {\n  var options = helper.copyOptions(userOptions);\n  helper.ensureFlagExists('ignoreDeclaration', options);\n  helper.ensureFlagExists('ignoreInstruction', options);\n  helper.ensureFlagExists('ignoreAttributes', options);\n  helper.ensureFlagExists('ignoreText', options);\n  helper.ensureFlagExists('ignoreComment', options);\n  helper.ensureFlagExists('ignoreCdata', options);\n  helper.ensureFlagExists('ignoreDoctype', options);\n  helper.ensureFlagExists('compact', options);\n  helper.ensureFlagExists('indentText', options);\n  helper.ensureFlagExists('indentCdata', options);\n  helper.ensureFlagExists('indentAttributes', options);\n  helper.ensureFlagExists('indentInstruction', options);\n  helper.ensureFlagExists('fullTagEmptyElement', options);\n  helper.ensureFlagExists('noQuotesForNativeAttributes', options);\n  helper.ensureSpacesExists(options);\n  if (typeof options.spaces === 'number') {\n    options.spaces = Array(options.spaces + 1).join(' ');\n  }\n  helper.ensureKeyExists('declaration', options);\n  helper.ensureKeyExists('instruction', options);\n  helper.ensureKeyExists('attributes', options);\n  helper.ensureKeyExists('text', options);\n  helper.ensureKeyExists('comment', options);\n  helper.ensureKeyExists('cdata', options);\n  helper.ensureKeyExists('doctype', options);\n  helper.ensureKeyExists('type', options);\n  helper.ensureKeyExists('name', options);\n  helper.ensureKeyExists('elements', options);\n  helper.checkFnExists('doctype', options);\n  helper.checkFnExists('instruction', options);\n  helper.checkFnExists('cdata', options);\n  helper.checkFnExists('comment', options);\n  helper.checkFnExists('text', options);\n  helper.checkFnExists('instructionName', options);\n  helper.checkFnExists('elementName', options);\n  helper.checkFnExists('attributeName', options);\n  helper.checkFnExists('attributeValue', options);\n  helper.checkFnExists('attributes', options);\n  helper.checkFnExists('fullTagEmptyElement', options);\n  return options;\n}\n\nfunction writeIndentation(options, depth, firstLine) {\n  return (!firstLine && options.spaces ? '\\n' : '') + Array(depth + 1).join(options.spaces);\n}\n\nfunction writeAttributes(attributes, options, depth) {\n  if (options.ignoreAttributes) {\n    return '';\n  }\n  if ('attributesFn' in options) {\n    attributes = options.attributesFn(attributes, currentElementName, currentElement);\n  }\n  var key, attr, attrName, quote, result = [];\n  for (key in attributes) {\n    if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== undefined) {\n      quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== 'string' ? '' : '\"';\n      attr = '' + attributes[key]; // ensure number and boolean are converted to String\n      attr = attr.replace(/\"/g, '&quot;');\n      attrName = 'attributeNameFn' in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;\n      result.push((options.spaces && options.indentAttributes? writeIndentation(options, depth+1, false) : ' '));\n      result.push(attrName + '=' + quote + ('attributeValueFn' in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);\n    }\n  }\n  if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {\n    result.push(writeIndentation(options, depth, false));\n  }\n  return result.join('');\n}\n\nfunction writeDeclaration(declaration, options, depth) {\n  currentElement = declaration;\n  currentElementName = 'xml';\n  return options.ignoreDeclaration ? '' :  '<?' + 'xml' + writeAttributes(declaration[options.attributesKey], options, depth) + '?>';\n}\n\nfunction writeInstruction(instruction, options, depth) {\n  if (options.ignoreInstruction) {\n    return '';\n  }\n  var key;\n  for (key in instruction) {\n    if (instruction.hasOwnProperty(key)) {\n      break;\n    }\n  }\n  var instructionName = 'instructionNameFn' in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;\n  if (typeof instruction[key] === 'object') {\n    currentElement = instruction;\n    currentElementName = instructionName;\n    return '<?' + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + '?>';\n  } else {\n    var instructionValue = instruction[key] ? instruction[key] : '';\n    if ('instructionFn' in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);\n    return '<?' + instructionName + (instructionValue ? ' ' + instructionValue : '') + '?>';\n  }\n}\n\nfunction writeComment(comment, options) {\n  return options.ignoreComment ? '' : '<!--' + ('commentFn' in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + '-->';\n}\n\nfunction writeCdata(cdata, options) {\n  return options.ignoreCdata ? '' : '<![CDATA[' + ('cdataFn' in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace(']]>', ']]]]><![CDATA[>')) + ']]>';\n}\n\nfunction writeDoctype(doctype, options) {\n  return options.ignoreDoctype ? '' : '<!DOCTYPE ' + ('doctypeFn' in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + '>';\n}\n\nfunction writeText(text, options) {\n  if (options.ignoreText) return '';\n  text = '' + text; // ensure Number and Boolean are converted to String\n  text = text.replace(/&amp;/g, '&'); // desanitize to avoid double sanitization\n  text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n  return 'textFn' in options ? options.textFn(text, currentElementName, currentElement) : text;\n}\n\nfunction hasContent(element, options) {\n  var i;\n  if (element.elements && element.elements.length) {\n    for (i = 0; i < element.elements.length; ++i) {\n      switch (element.elements[i][options.typeKey]) {\n      case 'text':\n        if (options.indentText) {\n          return true;\n        }\n        break; // skip to next key\n      case 'cdata':\n        if (options.indentCdata) {\n          return true;\n        }\n        break; // skip to next key\n      case 'instruction':\n        if (options.indentInstruction) {\n          return true;\n        }\n        break; // skip to next key\n      case 'doctype':\n      case 'comment':\n      case 'element':\n        return true;\n      default:\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction writeElement(element, options, depth) {\n  currentElement = element;\n  currentElementName = element.name;\n  var xml = [], elementName = 'elementNameFn' in options ? options.elementNameFn(element.name, element) : element.name;\n  xml.push('<' + elementName);\n  if (element[options.attributesKey]) {\n    xml.push(writeAttributes(element[options.attributesKey], options, depth));\n  }\n  var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';\n  if (!withClosingTag) {\n    if ('fullTagEmptyElementFn' in options) {\n      withClosingTag = options.fullTagEmptyElementFn(element.name, element);\n    } else {\n      withClosingTag = options.fullTagEmptyElement;\n    }\n  }\n  if (withClosingTag) {\n    xml.push('>');\n    if (element[options.elementsKey] && element[options.elementsKey].length) {\n      xml.push(writeElements(element[options.elementsKey], options, depth + 1));\n      currentElement = element;\n      currentElementName = element.name;\n    }\n    xml.push(options.spaces && hasContent(element, options) ? '\\n' + Array(depth + 1).join(options.spaces) : '');\n    xml.push('</' + elementName + '>');\n  } else {\n    xml.push('/>');\n  }\n  return xml.join('');\n}\n\nfunction writeElements(elements, options, depth, firstLine) {\n  return elements.reduce(function (xml, element) {\n    var indent = writeIndentation(options, depth, firstLine && !xml);\n    switch (element.type) {\n    case 'element': return xml + indent + writeElement(element, options, depth);\n    case 'comment': return xml + indent + writeComment(element[options.commentKey], options);\n    case 'doctype': return xml + indent + writeDoctype(element[options.doctypeKey], options);\n    case 'cdata': return xml + (options.indentCdata ? indent : '') + writeCdata(element[options.cdataKey], options);\n    case 'text': return xml + (options.indentText ? indent : '') + writeText(element[options.textKey], options);\n    case 'instruction':\n      var instruction = {};\n      instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];\n      return xml + (options.indentInstruction ? indent : '') + writeInstruction(instruction, options, depth);\n    }\n  }, '');\n}\n\nfunction hasContentCompact(element, options, anyContent) {\n  var key;\n  for (key in element) {\n    if (element.hasOwnProperty(key)) {\n      switch (key) {\n      case options.parentKey:\n      case options.attributesKey:\n        break; // skip to next key\n      case options.textKey:\n        if (options.indentText || anyContent) {\n          return true;\n        }\n        break; // skip to next key\n      case options.cdataKey:\n        if (options.indentCdata || anyContent) {\n          return true;\n        }\n        break; // skip to next key\n      case options.instructionKey:\n        if (options.indentInstruction || anyContent) {\n          return true;\n        }\n        break; // skip to next key\n      case options.doctypeKey:\n      case options.commentKey:\n        return true;\n      default:\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction writeElementCompact(element, name, options, depth, indent) {\n  currentElement = element;\n  currentElementName = name;\n  var elementName = 'elementNameFn' in options ? options.elementNameFn(name, element) : name;\n  if (typeof element === 'undefined' || element === null || element === '') {\n    return 'fullTagEmptyElementFn' in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? '<' + elementName + '></' + elementName + '>' : '<' + elementName + '/>';\n  }\n  var xml = [];\n  if (name) {\n    xml.push('<' + elementName);\n    if (typeof element !== 'object') {\n      xml.push('>' + writeText(element,options) + '</' + elementName + '>');\n      return xml.join('');\n    }\n    if (element[options.attributesKey]) {\n      xml.push(writeAttributes(element[options.attributesKey], options, depth));\n    }\n    var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';\n    if (!withClosingTag) {\n      if ('fullTagEmptyElementFn' in options) {\n        withClosingTag = options.fullTagEmptyElementFn(name, element);\n      } else {\n        withClosingTag = options.fullTagEmptyElement;\n      }\n    }\n    if (withClosingTag) {\n      xml.push('>');\n    } else {\n      xml.push('/>');\n      return xml.join('');\n    }\n  }\n  xml.push(writeElementsCompact(element, options, depth + 1, false));\n  currentElement = element;\n  currentElementName = name;\n  if (name) {\n    xml.push((indent ? writeIndentation(options, depth, false) : '') + '</' + elementName + '>');\n  }\n  return xml.join('');\n}\n\nfunction writeElementsCompact(element, options, depth, firstLine) {\n  var i, key, nodes, xml = [];\n  for (key in element) {\n    if (element.hasOwnProperty(key)) {\n      nodes = isArray(element[key]) ? element[key] : [element[key]];\n      for (i = 0; i < nodes.length; ++i) {\n        switch (key) {\n        case options.declarationKey: xml.push(writeDeclaration(nodes[i], options, depth)); break;\n        case options.instructionKey: xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : '') + writeInstruction(nodes[i], options, depth)); break;\n        case options.attributesKey: case options.parentKey: break; // skip\n        case options.textKey: xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : '') + writeText(nodes[i], options)); break;\n        case options.cdataKey: xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : '') + writeCdata(nodes[i], options)); break;\n        case options.doctypeKey: xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options)); break;\n        case options.commentKey: xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options)); break;\n        default: xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));\n        }\n        firstLine = firstLine && !xml.length;\n      }\n    }\n  }\n  return xml.join('');\n}\n\nmodule.exports = function (js, options) {\n  options = validateOptions(options);\n  var xml = [];\n  currentElement = js;\n  currentElementName = '_root_';\n  if (options.compact) {\n    xml.push(writeElementsCompact(js, options, 0, true));\n  } else {\n    if (js[options.declarationKey]) {\n      xml.push(writeDeclaration(js[options.declarationKey], options, 0));\n    }\n    if (js[options.elementsKey] && js[options.elementsKey].length) {\n      xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length));\n    }\n  }\n  return xml.join('');\n};\n","var js2xml = require('./js2xml.js');\r\n\r\nmodule.exports = function (json, options) {\r\n  if (json instanceof Buffer) {\r\n    json = json.toString();\r\n  }\r\n  var js = null;\r\n  if (typeof (json) === 'string') {\r\n    try {\r\n      js = JSON.parse(json);\r\n    } catch (e) {\r\n      throw new Error('The JSON structure is invalid');\r\n    }\r\n  } else {\r\n    js = json;\r\n  }\r\n  return js2xml(js, options);\r\n};\r\n","/*jslint node:true */\r\n\r\nvar xml2js = require('./xml2js');\r\nvar xml2json = require('./xml2json');\r\nvar js2xml = require('./js2xml');\r\nvar json2xml = require('./json2xml');\r\n\r\nmodule.exports = {\r\n  xml2js: xml2js,\r\n  xml2json: xml2json,\r\n  js2xml: js2xml,\r\n  json2xml: json2xml\r\n};\r\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst Attributes = ({ attributes, theme }) => {\n    let attributeList = [];\n    const overflow = theme.overflowBreak ? { overflowWrap: 'break-word', whiteSpace: 'normal' } : {} \n\n    for (const key in attributes) {\n        attributeList.push(\n            <span key={`attr-${key}[${attributes[key]}]`}>\n                <span style={{ color: theme.attributeKeyColor }}>{` ${key}`}</span>\n                <span style={{ color: theme.separatorColor }}>{\"=\"}</span>\n                <span style={{ color: theme.attributeValueColor }}>{`\"${attributes[key]}\"`}</span>\n            </span>\n        );\n    }\n\n    return (\n        <span style={overflow}>{attributeList}</span>\n    );\n}\n\nAttributes.propTypes = {\n    attributes: PropTypes.object,\n    theme: PropTypes.object.isRequired,\n};\n\n\nexport default Attributes;","import React from 'react';\nimport Attributes from './attributes';\nimport PropTypes from 'prop-types';\n\nconst DeclarationElement = ({ attributes, theme }) => {\n    return (\n        <div>\n            <span style={{ color: theme.separatorColor }}>{`<?`}</span>\n            <span style={{ color: theme.tagColor }}>{\"xml\"}</span>\n            <Attributes attributes={attributes} theme={theme} />\n            <span style={{ color: theme.separatorColor }}>{`?>`}</span>\n        </div>\n    );\n}\n\nDeclarationElement.propTypes = {\n    attributes: PropTypes.object.isRequired,\n    theme: PropTypes.object.isRequired,\n}\n\nexport default DeclarationElement;","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst CdataElement = ({ cdata, theme, indentation }) => {\n    return (\n        <div style={{ color: theme.cdataColor }}>\n            {`${indentation}<![CDATA[${cdata}]]>`}\n        </div>\n    );\n}\n\nCdataElement.propTypes = {\n    cdata: PropTypes.string.isRequired,\n    theme: PropTypes.object.isRequired,\n    indentation: PropTypes.string.isRequired,\n}\n\nexport default CdataElement;","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst CommentElement = ({ comment, theme, indentation }) => {\n    return (\n        <div style={{ color: theme.commentColor }}>\n            {`${indentation}<!-- ${comment} -->`}\n        </div>\n    );\n}\n\nCommentElement.propTypes = {\n    comment: PropTypes.string.isRequired,\n    theme: PropTypes.object.isRequired,\n    indentation: PropTypes.string.isRequired,\n}\n\nexport default CommentElement;","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst InstructionElement = ({ name, instruction, theme, indentation }) => {\n    return (\n        <div>\n            <span style={{ color: theme.separatorColor }}>{`${indentation}<?`}</span>\n            <span style={{ color: theme.tagColor }}>{name}</span>\n            <span style={{ color: theme.attributeKeyColor }}>{` ${instruction}`}</span>\n            <span style={{ color: theme.separatorColor }}>{`?>`}</span>\n        </div>);\n}\n\nInstructionElement.propTypes = {\n    name: PropTypes.string.isRequired,\n    instruction: PropTypes.string.isRequired,\n    theme: PropTypes.object.isRequired,\n    indentation: PropTypes.string.isRequired,\n}\n\nexport default InstructionElement;","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst TextElement = ({ text, theme }) => {\n    const overflow = theme.overflowBreak ? { overflowWrap: 'break-word', whiteSpace: 'normal' } : {} \n    return (\n        <span style={{ color: theme.textColor,  ...overflow }}>\n            {text}\n        </span>\n    );\n}\n\nTextElement.propTypes = {\n    text: PropTypes.string.isRequired,\n    theme: PropTypes.object.isRequired,\n}\n\nexport default TextElement;","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport Attributes from './attributes';\nimport CdataElement from './cdata-el';\nimport CommentElement from './comment-el';\nimport InstructionElement from './instruction-el';\nimport TextElement from './text-el';\n\nfunction getIndentationString(size) {\n    return new Array(size + 1).join(\" \");\n}\n\nfunction isTextElement(elements) {\n    return elements.length === 1 && elements[0].type === \"text\";\n}\n\nconst Element = ({ name, elements, attributes, theme, indentation, indentSize }) => {\n    return (\n        <div style={{ whiteSpace: 'pre' }}>\n            <span style={{ color: theme.separatorColor }}>{`${indentation}<`}</span>\n            <span style={{ color: theme.tagColor }}>{name}</span>\n            <Attributes attributes={attributes} theme={theme} />\n            <span style={{ color: theme.separatorColor }}>{(elements ? '>' : '/>')}</span>\n            {elements && <Elements elements={elements} theme={theme} indentation={indentation + getIndentationString(indentSize)} indentSize={indentSize} />}\n            {elements && <span style={{ color: theme.separatorColor }}>{`${isTextElement(elements) ? \"\" : indentation}</`}</span>}\n            {elements && <span style={{ color: theme.tagColor }}>{name}</span>}\n            {elements && <span style={{ color: theme.separatorColor }}>{\">\"}</span>}\n        </div>\n    );\n}\n\nElement.propTypes = {\n    name: PropTypes.string.isRequired,\n    elements: PropTypes.arrayOf(PropTypes.object),\n    attributes: PropTypes.object,\n    theme: PropTypes.object.isRequired,\n    indentation: PropTypes.string.isRequired,\n    indentSize: PropTypes.number.isRequired,\n}\n\nconst getElement = (theme, indentation, indentSize) => (element, index) => {\n    switch (element.type) {\n        case \"text\":\n            return <TextElement key={`el-${index}`} text={element.text} theme={theme} />;\n        case \"element\":\n            return <Element key={`el-${index}`} name={element.name} elements={element.elements} attributes={element.attributes} theme={theme} indentation={indentation} indentSize={indentSize} />\n        case \"comment\":\n            return <CommentElement key={`el-${index}`} comment={element.comment} theme={theme} indentation={indentation} />;\n        case \"cdata\":\n            return <CdataElement key={`el-${index}`} cdata={element.cdata} theme={theme} indentation={indentation} />;\n        case \"instruction\":\n            return <InstructionElement key={`el-${index}`} instruction={element.instruction} name={element.name} theme={theme} indentation={indentation} />;\n        default:\n            return null;\n    }\n}\n\nconst Elements = ({ elements, theme, indentation, indentSize }) => {\n    return elements.map(getElement(theme, indentation, indentSize));\n}\n\nElements.propTypes = {\n    elements: PropTypes.arrayOf(PropTypes.object),\n    theme: PropTypes.object.isRequired,\n    indentation: PropTypes.string.isRequired,\n    indentSize: PropTypes.number.isRequired,\n}\n\nexport default Elements;","import React from 'react';\nimport convert from 'xml-js';\nimport PropTypes from 'prop-types';\n\nimport DeclarationElement from './declaration-el';\nimport Elements from './elements';\n\nconst defaultIndentSize = 2;\nconst defaultTheme = {\n  tagColor: '#d43900',\n  textColor: '#333',\n  attributeKeyColor: '#2a7ab0',\n  attributeValueColor: '#008000',\n  separatorColor: '#333',\n  commentColor: '#aaa',\n  cdataColor: '#1d781d',\n  overflowBreak: false,\n};\n\nconst defaultInvalidXml = (<div>Invalid XML!</div>);\n\nconst XMLViewer = ({ xml, theme, indentSize, invalidXml, ...props }) => {\n  let json = null;\n  const customTheme = { ...defaultTheme, ...theme };\n\n  try {\n    json = convert.xml2js(xml, { compact: false, spaces: 0 });\n    if (!Array.isArray(json.elements)) {\n      return invalidXml;\n    }\n  } catch (e) {\n    return invalidXml;\n  }\n\n  return (\n    <div {...props}>\n      {json.declaration && <DeclarationElement theme={customTheme} attributes={json.declaration.attributes} />}\n      <Elements elements={json.elements} theme={customTheme} indentSize={indentSize} indentation=\"\" />\n    </div>\n  );\n}\n\nXMLViewer.propTypes = {\n    xml: PropTypes.string.isRequired,\n    theme: PropTypes.object,\n    indentSize: PropTypes.number,\n    invalidXml: PropTypes.node,\n}\n\nXMLViewer.defaultProps = {\n  theme: {},\n  indentSize: 2,\n  invalidXml: defaultInvalidXml,\n}\n\nexport default XMLViewer;\n\n"]},"metadata":{},"sourceType":"module"}